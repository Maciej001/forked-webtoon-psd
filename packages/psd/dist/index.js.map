{"version":3,"file":"index.js","sources":["../src/classes/Group.ts","../src/interfaces/AdditionalLayerInfo/AliKey.ts","../src/interfaces/AdditionalLayerInfo/SectionDividerSettingAliBlock.ts","../src/interfaces/AdditionalLayerInfo/VectorMaskSettingAliBlock.ts","../src/utils/array.ts","../src/utils/error.ts","../src/utils/bytes.ts","../src/utils/number.ts","../src/utils/boundingBox.ts","../src/interfaces/BlendMode.ts","../src/interfaces/Clipping.ts","../src/interfaces/ColorMode.ts","../src/interfaces/Depth.ts","../src/interfaces/Descriptor.ts","../src/sections/FileHeader/index.ts","../src/sections/ImageData/readRawData.ts","../src/sections/ImageData/readRleCompressedData.ts","../src/sections/ImageData/index.ts","../src/sections/ImageResource/readGridAndGuides.ts","../src/sections/ImageResource/readICCProfile.ts","../src/sections/ImageResource/readResolutionInfo.ts","../src/sections/ImageResource/readSlices.ts","../src/sections/ImageResource/index.ts","../src/sections/LayerAndMaskInformation/interfaces.ts","../src/sections/LayerAndMaskInformation/classes.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readArtboardDataAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readBlendOptionsCapacityAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readGradientFillSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readHueSaturationAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readLayerIdAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readLinkedLayerAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readObjectBasedEffectsAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readPatternFillSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readSectionDividerSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readSmartObjectPlacedLayerDataAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readSolidColorSheetSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readTypeToolObjectSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readUnicodeLayerNameAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readVectorMaskSettingAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readVectorStrokeContentDataAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/readVectorStrokeDataAliBlock.ts","../src/sections/LayerAndMaskInformation/AdditionalLayerInfo/index.ts","../src/sections/LayerAndMaskInformation/readLayerRecordsAndChannels.ts","../src/sections/LayerAndMaskInformation/index.ts","../src/sections/index.ts","../src/interfaces/FileVersionSpec.ts","../src/interfaces/ChannelCompression.ts","../src/interfaces/ChannelKind.ts","../src/interfaces/GroupDivider.ts","../src/interfaces/resources/GridAndGuidesResourceBlock.ts","../src/interfaces/resources/ResourceType.ts","../src/interfaces/resources/SlicesResourceBlock.ts","../src/interfaces/resources/ResolutionInfo.ts","../src/interfaces/Reference.ts","../src/methods/applyOpacity.ts","../../decoder/dist/index.js","../src/methods/generateRgba.ts","../src/methods/parse.ts","../src/methods/readDescriptor.ts","../src/engineData/lexer.ts","../src/engineData/parser.ts","../src/engineData/validator.ts","../src/methods/parseEngineData.ts","../src/classes/Synthesizable.ts","../src/classes/Layer.ts","../src/classes/Node.ts","../src/classes/Slice.ts","../src/classes/Psd.ts"],"sourcesContent":["// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {GroupFrame} from \"../sections\";\nimport {NodeChild, NodeParent} from \"./Node\";\nimport {NodeBase} from \"./NodeBase\";\n\n/**\n * A layer group, which may contain layers and other layer groups.\n * @alpha\n */\nexport class Group implements NodeBase<NodeParent, NodeChild> {\n  readonly type = \"Group\";\n  readonly children: NodeChild[] = [];\n\n  /** @internal */\n  constructor(\n    private layerFrame: GroupFrame | undefined,\n    public readonly parent: NodeParent\n  ) {}\n\n  get isHidden(): boolean {\n    return this.layerFrame?.layerProperties.hidden || true;\n  }\n\n  get name(): string {\n    return this.layerFrame?.layerProperties.name ?? \"\";\n  }\n  get opacity(): number {\n    return this.layerFrame?.layerProperties.opacity ?? 0;\n  }\n  get composedOpacity(): number {\n    return this.parent.composedOpacity * (this.opacity / 255);\n  }\n\n  get hidden(): boolean {\n    return this.layerFrame?.layerProperties.hidden || false;\n  }\n\n  addChild(node: NodeChild): void {\n    this.children.push(node);\n  }\n  hasChildren(): boolean {\n    return this.children.length !== 0;\n  }\n\n  freeze(): void {\n    this.children.forEach((node) => (node as NodeBase).freeze?.());\n    Object.freeze(this.children);\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/**\n * Keys for Additional Layer Info blocks that @webtoon/psd can parse.\n * Currently, only a subset of all possible keys are supported.\n */\nexport enum AliKey {\n  SectionDividerSetting = \"lsct\",\n  TypeToolObjectSetting = \"TySh\",\n  UnicodeLayerName = \"luni\",\n\n  VectorStrokeData = \"vstk\",\n  ObjectBasedEffects = \"lfx2\",\n  GradientFillSetting = \"GdFl\",\n  SolidColorSheetSetting = \"SoCo\",\n  PatternFillSetting = \"PtFl\",\n  VectorStrokeContentData = \"vscg\",\n  BlendOptionsCapacity = \"iOpa\",\n  VectorMaskSetting1 = \"vmsk\",\n  VectorMaskSetting2 = \"vsms\",\n  HueSaturation = \"hue2\",\n  NestedSectionDividerSetting = \"lsdk\",\n  LayerId = \"lyid\",\n  ArtboardData = \"artb\",\n  SmartObjectPlacedLayerData = \"SoLE\",\n  PlacedLayerData = \"SoLd\",\n\n  LinkedLayer = \"lnkD\",\n  LinkedLayer2 = \"lnk2\",\n  LinkedLayer3 = \"lnk3\",\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {BlendMode} from \"../BlendMode\";\nimport {GroupDivider} from \"../GroupDivider\";\nimport {KnownAliBlock} from \"./AliBlockBase\";\nimport {AliKey} from \"./AliKey\";\n\n/**\n * (Photoshop 6.0) ALI block that stores information about a section divider\n * (i.e. layer group divider).\n */\nexport type SectionDividerSettingAliBlock =\n  | SectionDividerSettingAliBlockBase\n  | SectionDividerSettingAliBlockExtra;\n\n/**\n * Minimal Section Divider block.\n */\ninterface SectionDividerSettingAliBlockBase\n  extends KnownAliBlock<\n    AliKey.SectionDividerSetting | AliKey.NestedSectionDividerSetting\n  > {\n  dividerType: GroupDivider;\n}\n\n/**\n * Section Divider block with additional fields.\n */\ninterface SectionDividerSettingAliBlockExtra\n  extends SectionDividerSettingAliBlockBase {\n  dividerSignature: \"8BIM\";\n  blendMode: BlendMode;\n  subType?: SectionDividerSubtype;\n}\n\nexport enum SectionDividerSubtype {\n  Normal = 0,\n  SceneGroup = 1,\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {KnownAliBlock} from \"./AliBlockBase\";\nimport {AliKey} from \"./AliKey\";\n\nexport type Point = {vert: number; horiz: number};\n\nexport enum PathRecordType {\n  ClosedSubpathLength = 0,\n  ClosedSubpathBezierKnotLinked = 1,\n  ClosedSubpathBezierKnotUnlinked = 2,\n  OpenSubpathLength = 3,\n  OpenSubpathBezierKnotLinked = 4,\n  OpenSubpathBezierKnotUnlinked = 5,\n  PathFillRule = 6,\n  Clipboard = 7,\n  InitialFillRule = 8,\n}\n\nexport type PathRecord =\n  // Path record\n  | {\n      type:\n        | PathRecordType.ClosedSubpathLength\n        | PathRecordType.OpenSubpathLength;\n      length: number;\n      operation: number;\n      subpathType: number;\n      index: number;\n    }\n  // Bezier pont\n  | {\n      type:\n        | PathRecordType.ClosedSubpathBezierKnotLinked\n        | PathRecordType.ClosedSubpathBezierKnotUnlinked\n        | PathRecordType.OpenSubpathBezierKnotLinked\n        | PathRecordType.OpenSubpathBezierKnotUnlinked;\n      preceding: Point;\n      anchor: Point;\n      leaving: Point;\n    }\n  // Path fill rule\n  | {\n      type: PathRecordType.PathFillRule;\n    }\n  // Clipboard\n  | {\n      type: PathRecordType.Clipboard;\n      bounds: [number, number, number, number];\n      resolution: number;\n    }\n  // Initial fill\n  | {\n      type: PathRecordType.InitialFillRule;\n      fill: boolean;\n    };\n\nexport interface VectorMaskSettingAliBlock\n  extends KnownAliBlock<AliKey.VectorMaskSetting1 | AliKey.VectorMaskSetting2> {\n  version: number;\n  invert: boolean;\n  notLink: boolean;\n  disable: boolean;\n  // https://github.com/layervault/psd.rb/blob/master/lib/psd/path_record.rb\n  pathRecords: PathRecord[];\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nexport const equals = (\n  compare: number[] | Uint8Array,\n  target: number[] | Uint8Array\n): boolean => {\n  const length = Math.max(compare.length, target.length);\n  for (let i = 0; i < length; i++) {\n    if (compare[i] !== target[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/**\n * Base class for all exceptions thrown by @webtoon/psd\n */\nexport class PsdError extends Error {\n  // Workaround to properly set the prototype chain in Node.js\n  // See:\n  // - https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n  // - https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = new.target.name;\n  }\n}\n\nexport class InvalidBufferLength extends PsdError {}\nexport class InvalidSignature extends PsdError {}\nexport class InvalidVersion extends PsdError {}\nexport class InvalidReservationCode extends PsdError {}\nexport class InvalidColorMode extends PsdError {}\nexport class InvalidDepth extends PsdError {}\nexport class InvalidChannelCount extends PsdError {}\nexport class InvalidPixelCount extends PsdError {}\nexport class InvalidChannel extends PsdError {}\nexport class InvalidBlendingModeSignature extends PsdError {}\nexport class InvalidGroupDividerType extends PsdError {}\nexport class UnknownBlendingMode extends PsdError {}\nexport class InvalidCompression extends PsdError {}\n\n/**\n * Error thrown when the PSD file uses a compression format that is valid, but\n * currently unsupported by @webtoon/psd\n */\nexport class UnsupportedCompression extends PsdError {}\nexport class UnsupportedDepth extends PsdError {}\nexport class UnsupportedChannelKindOffset extends PsdError {}\nexport class ChannelNotFound extends PsdError {}\nexport class InvalidClipping extends PsdError {}\nexport class PanicFrameStackUnmatched extends PsdError {}\nexport class InvalidOpacityValue extends PsdError {}\nexport class UnknownEffectsLayerVersion extends PsdError {}\nexport class InvalidEffectsLayerSignature extends PsdError {}\nexport class InvalidResourceSignature extends PsdError {}\nexport class PanicOutOfBoundArray extends PsdError {}\n\n// Grid and Guides-related errors\nexport class InvalidGridAndGuidesVersion extends PsdError {}\nexport class InvalidGuideDirection extends PsdError {}\n\n// Slices-related errors\nexport class InvalidSlicesVersion extends PsdError {}\nexport class InvalidSliceOrigin extends PsdError {}\nexport class InvalidSlice extends PsdError {}\n\n/**\n * Error thrown when a value exceeds the limit supported by @webtoon/psd.\n * (This includes negative values that are too small)\n */\nexport class NumberTooLarge extends PsdError {}\n\n// Additional Layer Information section errors\nexport class InvalidAdditionalLayerInfoSignature extends PsdError {}\nexport class InvalidSectionDividerSetting extends PsdError {}\nexport class InvalidTypeToolObjectSetting extends PsdError {}\nexport class InvalidLinkedLayerType extends PsdError {}\n\n// Descriptor and Reference errors\nexport class InvalidDescriptorType extends PsdError {}\nexport class InvalidDescriptorVersion extends PsdError {}\nexport class DuplicateDescriptorKey extends PsdError {}\n/** Thrown when a descriptor does not contain the expected key */\nexport class MissingDescriptorKey extends PsdError {}\n/** Thrown when a descriptor value is not of the expected type */\nexport class UnexpectedDescriptorValueType extends PsdError {}\nexport class InvalidReferenceType extends PsdError {}\nexport class InvalidUnitFloatType extends PsdError {}\n\n// EngineData errors\n/** Thrown when lexer fails to parse respective type */\nexport class InvalidEngineDataBoolean extends PsdError {}\nexport class InvalidEngineDataNumber extends PsdError {}\n/** Thrown when top-level value is not a dict */\nexport class InvalidTopLevelEngineDataValue extends PsdError {}\nexport class UnexpectedEndOfEngineData extends PsdError {}\nexport class UnexpectedEngineDataToken extends PsdError {}\nexport class InvalidEngineDataDictKey extends PsdError {}\nexport class InvalidEngineDataTextBOM extends PsdError {}\nexport class MissingEngineDataProperties extends PsdError {}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {NumberTooLarge, PanicOutOfBoundArray} from \"./error\";\n\nexport type ReadType =\n  | \"u8\"\n  | \"u16\"\n  | \"u32\"\n  | \"u64\"\n  | \"i8\"\n  | \"i16\"\n  | \"i32\"\n  | \"i64\"\n  | \"f32\"\n  | \"f64\";\n\n// The following two functions are used to safely decode a subset of 64-bit\n// integers into regular JavaScript numbers without using BigInt.\n// TODO: Remove these when we can use BigInt\n\n/**\n * Decodes a 64-bit region at the given byte offset of the `DataView` as an\n * unsigned 64-bit integer (big endian).\n *\n * If the parsed value is too large to safely fit into a JavaScript `Number`,\n * throws an error.\n * @param data DataView\n * @param byteOffset\n */\nexport function getUint64FromDataView(\n  data: DataView,\n  byteOffset: number\n): number {\n  const upper = data.getUint32(byteOffset);\n  const lower = data.getUint32(byteOffset + 4);\n\n  // Throw if the value is greater than MAX_SAFE_INTEGER (2^53 - 1)\n  if (upper >= 0x20_0000) {\n    throw new NumberTooLarge();\n  }\n\n  return upper * 0x1_0000_0000 + lower;\n}\n\n/**\n * Decodes a 64-bit region at the given byte offset of the `DataView` as a\n * signed 64-bit integer (big endian).\n *\n * If the parsed value is too large to safely fit into a JavaScript `Number`,\n * throws an error.\n * @param data DataView\n * @param byteOffset\n */\nexport function getInt64FromDataView(\n  data: DataView,\n  byteOffset: number\n): number {\n  const upper = data.getInt32(byteOffset); // upper must be decoded as signed value\n  const lower = data.getUint32(byteOffset + 4);\n\n  // Throw if the value is greater than MAX_SAFE_INTEGER (2^53 - 1) or less\n  // than MIN_SAFE_INTEGER (-(2^53 - 1))\n  if (\n    upper >= 0x20_0000 ||\n    upper < -0x20_0000 ||\n    (upper === -0x20_0000 && lower === 0)\n  ) {\n    throw new NumberTooLarge();\n  }\n\n  return upper * 0x1_0000_0000 + lower;\n}\n\nconst INCREASE: {[type in ReadType]: number} = {\n  u8: 1,\n  i8: 1,\n  u16: 2,\n  i16: 2,\n  u32: 4,\n  i32: 4,\n  f32: 4,\n  u64: 8,\n  i64: 8,\n  f64: 8,\n};\n\n/**\n * Utility class that wraps around a `DataView` and tracks the current offset\n * being parsed.\n */\nexport class Cursor {\n  static from(bytes: Uint8Array) {\n    return new Cursor(\n      new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n    );\n  }\n\n  constructor(private dataView: DataView, public position = 0) {}\n\n  /**\n   * Length of the data covered by this Cursor.\n   */\n  get length(): number {\n    return this.dataView.byteLength;\n  }\n\n  /**\n   * Clones the cursor, optionally specifying a new cursor position.\n   */\n  clone(position?: number): Cursor {\n    const pos = position !== undefined ? position : this.position;\n\n    return new Cursor(\n      new DataView(\n        this.dataView.buffer,\n        this.dataView.byteOffset,\n        this.dataView.byteLength\n      ),\n      pos\n    );\n  }\n\n  pass(length: number): void {\n    this.position += length;\n  }\n\n  unpass(length: number): void {\n    this.position -= length;\n  }\n\n  /**\n   * Creates a `Uint8Array` that covers the underlying `ArrayBuffer` of this\n   * cursor, starting at the current cursor position and spanning a\n   * {@link length} number of bytes.\n   * This does not advance the cursor.\n   */\n  extract(length: number): Uint8Array {\n    // The Uint8Array() constructor will throw if length < 0, so we don't need\n    // a check.\n    // However, if our DataView covers a subset of the underlying ArrayBuffer,\n    // the cursor can technically read beyond the end of the DataView.\n    // To prevent this, we must directly check the byte length being accessed.\n    if (this.position + length > this.dataView.byteLength) {\n      throw new PanicOutOfBoundArray();\n    }\n\n    return new Uint8Array(\n      this.dataView.buffer,\n      this.dataView.byteOffset + this.position,\n      length\n    );\n  }\n\n  iter(): Uint8Array {\n    return new Uint8Array(\n      this.dataView.buffer,\n      this.dataView.byteOffset + this.position\n    );\n  }\n\n  /**\n   * Creates a `Uint8Array` that covers the underlying `ArrayBuffer` of this\n   * cursor, starting at the current cursor position and spanning a\n   * {@link length} number of bytes.\n   * This advances the cursor by `length` bytes.\n   */\n  take(length: number): Uint8Array {\n    const bytes = this.extract(length);\n    this.pass(length);\n\n    return bytes;\n  }\n\n  /**\n   * Returns subsequent byte, without advancing position\n   */\n  peek(): number {\n    // dataView throws RangeError if position is outside bounds\n    return this.dataView.getUint8(this.position);\n  }\n\n  /**\n   * Returns subsequent byte\n   */\n  one(): number {\n    // dataView throws RangeError if position is outside bounds\n    const val = this.dataView.getUint8(this.position);\n    this.position += 1;\n    return val;\n  }\n\n  /**\n   * Reads a number at the current cursor position, using the given {@link type}\n   * (big endian).\n   * This advances the cursor by the size of the data `type`.\n   */\n  read(type: ReadType): number {\n    const {dataView, position} = this;\n    this.pass(INCREASE[type]);\n\n    switch (type) {\n      case \"u8\":\n        return dataView.getUint8(position);\n      case \"u16\":\n        return dataView.getUint16(position);\n      case \"u32\":\n        return dataView.getUint32(position);\n      case \"u64\":\n        return getUint64FromDataView(dataView, position);\n      case \"i8\":\n        return dataView.getInt8(position);\n      case \"i16\":\n        return dataView.getInt16(position);\n      case \"i32\":\n        return dataView.getInt32(position);\n      case \"i64\":\n        return getInt64FromDataView(dataView, position);\n      case \"f32\":\n        return dataView.getFloat32(position);\n      case \"f64\":\n        return dataView.getFloat64(position);\n      default:\n        throw new TypeError(`Invalid ReadType: ${type}`);\n    }\n  }\n\n  /**\n   * Reads {@link length} bytes of data and decodes it as a UTF-8 string.\n   * This advances the cursor by `length` bytes.\n   * @param length Length of the data to read in bytes\n   * @returns Decoded string\n   */\n  readString(length: number): string {\n    const data = this.take(length);\n    const result = new TextDecoder().decode(data);\n    return result;\n  }\n\n  /**\n   * Reads the length of the string (u32 field) at the current cursor position,\n   * then reads the rest of the string and decodes it as UTF-16BE.\n   * This advances the cursor.\n   *\n   * If {@link padding} is specified, this skips additional bytes until the\n   * total number of bytes advanced is a multiple of `padding`\n   * @param padding Padding (alignment) byte count\n   * @returns Decoded string\n   */\n  // TODO: Default padding of 4 is probably nonsensical and surprising.\n  // Let's change it to 0 and update all call sites.\n  readUnicodeString(padding = 4): string {\n    const length = this.read(\"u32\");\n\n    // UTF-16 encoding - two bytes per character\n    const lengthBytes = length * 2;\n    const data = this.take(lengthBytes);\n    const result = new TextDecoder(\"utf-16be\").decode(data);\n\n    // Increase position for padding\n    this.padding(4 + lengthBytes, padding);\n\n    // Some strings (e.g. layer text) may be null(0)-terminated\n    // If so, strip the final character\n    if (result.charCodeAt(result.length - 1) === 0) {\n      return result.slice(0, -1);\n    }\n\n    return result;\n  }\n\n  /**\n   * Reads unsigned 4-byte fixed-point number.\n   * 32 bits in 16.16 setup\n   * https://github.com/meltingice/psd.js/blob/333dd1467452a3353018c2856e3e4fb0e07d0025/lib/psd/resources/resolution_info.coffee#L10\n   */\n  readFixedPoint32bit(): number {\n    const int = this.read(\"u32\");\n    return int / (1 << 16);\n  }\n\n  /**\n   * Decodes an \"ID string\", which is a compact string format used in\n   * Descriptors.\n   *\n   * Reads the length of the string (u32 field) at the current cursor position,\n   * then reads the rest of the string and decodes it as UTF-8.\n   * If the value of the length field is 0, this always decodes 4 bytes of\n   * characters.\n   */\n  readIdString(): string {\n    const length = this.read(\"u32\");\n    return this.readString(length || 4);\n  }\n\n  /**\n   * Skips an amount of bytes so that a {@link size}-byte block is aligned to a\n   * multiple of {@link divisor}.\n   *\n   * @example\n   * // Skips 5 bytes, which aligns a 75-byte block to a\n   * // multiple of 8\n   * cursor.padding(75, 8);\n   *\n   * @param size Value to align against\n   * @param divisor Alignment number (can be 0)\n   */\n  padding(size: number, divisor: number): void {\n    const remainder = size % divisor;\n    if (remainder > 0) {\n      this.pass(divisor - remainder);\n    }\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nexport const inRange = (x: number, min: number, max: number): boolean =>\n  min <= x && x <= max;\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\ninterface BoundingBox {\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n}\n\nexport function height(boundingBox: BoundingBox): number {\n  return boundingBox.bottom - boundingBox.top;\n}\n\nexport function width(boundingBox: BoundingBox): number {\n  return boundingBox.right - boundingBox.left;\n}\n\nexport function dimensions(boundingBox: BoundingBox): {\n  height: number;\n  width: number;\n} {\n  return {width: width(boundingBox), height: height(boundingBox)};\n}\n\nexport function area(boundingBox: BoundingBox): number {\n  return width(boundingBox) * height(boundingBox);\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {UnknownBlendingMode} from \"../utils\";\n\nexport enum BlendMode {\n  PassThrough = \"pass\",\n  Normal = \"norm\",\n  Dissolve = \"diss\",\n  Darken = \"dark\",\n  Multiply = \"mul \",\n  ColorBurn = \"idiv\",\n  LinearBurn = \"lbrn\",\n  DarkerColor = \"dkCl\",\n  Lighten = \"lite\",\n  Screen = \"scrn\",\n  ColorDodge = \"div \",\n  LinearDodge = \"lddg\",\n  LighterColor = \"lgCl\",\n  Overlay = \"over\",\n  SoftLight = \"sLit\",\n  HardLight = \"hLit\",\n  VividLight = \"vLit\",\n  LinearLight = \"lLit\",\n  PinLight = \"pLit\",\n  HardMix = \"hMix\",\n  Difference = \"diff\",\n  Exclusion = \"smud\",\n  Subtract = \"fsub\",\n  Divide = \"fdiv\",\n  Hue = \"hue \",\n  Saturation = \"sat \",\n  Color = \"colr\",\n  Luminosity = \"lum \",\n}\n\nexport function matchBlendMode(mode: string): BlendMode {\n  const keys = Object.keys(BlendMode);\n  for (const key of keys) {\n    if (BlendMode[key as keyof typeof BlendMode] === mode) {\n      return mode as BlendMode;\n    }\n  }\n\n  throw new UnknownBlendingMode();\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {InvalidClipping} from \"../utils\";\n\nexport enum Clipping {\n  Base = 0,\n  NonBase = 1,\n}\n\nexport function matchClipping(mode: number): Clipping {\n  if (mode === Clipping.Base) return Clipping.Base;\n  if (mode === Clipping.NonBase) return Clipping.NonBase;\n\n  throw new InvalidClipping();\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/**\n * Possible color modes of a PSD file.\n * @alpha\n */\nexport enum ColorMode {\n  Bitmap = 0,\n  Grayscale = 1,\n  Indexed = 2,\n  Rgb = 3,\n  Cmyk = 4,\n  Multichannel = 7,\n  Duotone = 8,\n  Lab = 9,\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/**\n * Color depth (# of bits per channel) of a PSD file.\n * @alpha\n */\nexport enum Depth {\n  One = 1,\n  Eight = 8,\n  Sixteen = 16,\n  ThirtyTwo = 32,\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {MissingDescriptorKey, UnexpectedDescriptorValueType} from \"../utils\";\nimport {Reference} from \"./Reference\";\n\n/**\n * Descriptors are dictionary-like data structures that Photoshop uses to store\n * arbitrary key-value data.\n */\nexport interface Descriptor {\n  name: string;\n  classId: string;\n  items: Map<string, DescriptorValue>;\n}\n\n/**\n * Descriptor with an associated version.\n */\nexport interface VersionedDescriptor {\n  descriptorVersion: 16;\n  descriptor: Descriptor;\n}\n\n// DescriptorValue and its subtypes\n\nexport type DescriptorValue =\n  | AliasDescriptorValue\n  | BooleanDescriptorValue\n  | ClassDescriptorValue\n  | DescriptorDescriptorValue\n  | DoubleDescriptorValue\n  | EnumeratedDescriptorValue\n  | IntegerDescriptorValue\n  | LargeIntegerDescriptorValue\n  | ListDescriptorValue\n  | RawDataDescriptorValue\n  | ReferenceDescriptorValue\n  | StringDescriptorValue\n  | UnitFloatDescriptorValue\n  | ObjectArrayDescriptorValue\n  | UnitFloatsDescriptorValue;\n\ninterface DescriptorValueBase<Type extends DescriptorValueType> {\n  type: Type;\n}\n\n/** Possible values for the `type` field in `DescriptorValue` objects. */\nexport enum DescriptorValueType {\n  Alias = \"alis\",\n  Boolean = \"bool\",\n  Class = \"type\",\n  Descriptor = \"Objc\",\n  Double = \"doub\",\n  Enumerated = \"enum\",\n  /** Effectively the same as `DescriptorValueType.Class` */\n  GlobalClass = \"GlbC\",\n  /** Effectively the same as `DescriptorValueType.Descriptor` */\n  GlobalObject = \"GlbO\",\n  Integer = \"long\",\n  LargeInteger = \"comp\",\n  List = \"VlLs\",\n  RawData = \"tdta\",\n  Reference = \"obj \",\n  String = \"TEXT\",\n  UnitFloat = \"UntF\",\n  UnitFloats = \"UnFl\",\n  ObjectArray = \"ObAr\",\n}\n\nexport interface AliasDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Alias> {\n  /**\n   * Adobe's documentation says:\n   * \"FSSpec for Macintosh or a handle to a string to the full path on Windows\".\n   *\n   * Since it's unclear what this means, we provide the raw data rather than\n   * attempting to parse it.\n   */\n  // TODO: Research how this field should be decoded\n  data: Uint8Array;\n}\n\nexport interface BooleanDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Boolean> {\n  value: boolean;\n}\n\nexport interface ClassDescriptorValue\n  extends DescriptorValueBase<\n    DescriptorValueType.Class | DescriptorValueType.GlobalClass\n  > {\n  name: string;\n  classId: string;\n}\n\nexport interface DescriptorDescriptorValue\n  extends DescriptorValueBase<\n    DescriptorValueType.Descriptor | DescriptorValueType.GlobalObject\n  > {\n  descriptor: Descriptor;\n}\n\nexport interface DoubleDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Double> {\n  /** 64-bit floating-point number */\n  value: number;\n}\n\nexport interface EnumeratedDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Enumerated> {\n  enumType: string;\n  enumValue: string;\n}\n\nexport interface IntegerDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Integer> {\n  /** 32-bit integer */\n  value: number;\n}\n\nexport interface LargeIntegerDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.LargeInteger> {\n  /** 64-bit integer */\n  value: number;\n}\n\nexport interface ListDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.List> {\n  values: DescriptorValue[];\n}\n\nexport interface RawDataDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.RawData> {\n  data: Uint8Array;\n}\n\nexport interface ReferenceDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.Reference> {\n  references: Reference[];\n}\n\nexport interface StringDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.String> {\n  value: string;\n}\n\nexport interface UnitFloatDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.UnitFloat> {\n  unitType: UnitFloatType;\n  /** 64-bit floating-point number */\n  value: number;\n}\n\nexport interface ObjectArrayDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.ObjectArray> {\n  classObj: {name: string; classId: string};\n  items: {key: string; value: DescriptorValue}[];\n}\n\nexport interface UnitFloatsDescriptorValue\n  extends DescriptorValueBase<DescriptorValueType.UnitFloats> {\n  unitType: UnitFloatType;\n  /** 64-bit floating-point number */\n  values: number[];\n}\n\n/** Valid measurement unit types used by `UnitFloatDescriptorValue` */\nexport enum UnitFloatType {\n  // The following descriptions were taken directly from Adobe's docs\n  /** Base degrees */\n  Angle = \"#Ang\",\n  /** Base per inch */\n  Density = \"#Rsl\",\n  /** Base 72ppi */\n  Distance = \"#Rlt\",\n  /** Tagged unit value */\n  Millimeters = \"#Mlm\",\n  /** None */\n  None = \"#Nne\",\n  /** Unit value */\n  Percent = \"#Prc\",\n  /** Tagged unit value */\n  Pixels = \"#Pxl\",\n  /** Tagged unit value */\n  Points = \"#Pnt\",\n}\n\n/**\n * Helper type that maps a `DescriptorValueType` to a `DescriptorValue` subtype\n */\n// Use conditional types twice to distribute the check over each type in the\n// `DescriptorValue` union type\ntype DescriptorValueWithType<\n  Type extends DescriptorValueType,\n  D extends DescriptorValue = DescriptorValue\n> = D extends unknown ? (Type extends D[\"type\"] ? D : never) : never;\n\n/**\n * Retrieves an item in `descriptor` with the `key` as the given `valueType`.\n * @param descriptor\n * @param key\n * @param valueType Desired value type\n * @throws {MissingDescriptorKey} If the key does not exist\n * @throws {UnexpectedDescriptorValueType} If the value type does not match\n *    `valueType`\n */\nexport function getDescriptorValueAsType<Type extends DescriptorValueType>(\n  descriptor: Descriptor,\n  key: string,\n  valueType: Type\n): DescriptorValueWithType<Type> {\n  const value = descriptor.items.get(key);\n\n  if (!value) {\n    throw new MissingDescriptorKey(`Cannot find key \"${key}\" in descriptor`);\n  }\n\n  if (value.type !== valueType) {\n    throw new UnexpectedDescriptorValueType(\n      `Unexpected descriptor value type: expected \"${valueType}\" but got \"${value.type}\"`\n    );\n  }\n\n  return value as DescriptorValueWithType<Type>;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ColorMode, Depth, getFileVersionSpec} from \"../../interfaces\";\nimport {\n  Cursor,\n  equals,\n  inRange,\n  InvalidChannelCount,\n  InvalidColorMode,\n  InvalidDepth,\n  InvalidPixelCount,\n  InvalidReservationCode,\n  InvalidSignature,\n  InvalidVersion,\n} from \"../../utils\";\n\nexport enum PsdVersion {\n  PSD = 1,\n  PSB = 2,\n}\n\nconst EXPECTED_SIGNATURE = [56, 66, 80, 83];\nconst EXPECTED_RESERVED = [0, 0, 0, 0, 0, 0];\nconst EXPECTED_DEPTH_KINDS = [1, 8, 16, 32];\n\nconst MIN_CHANNEL_COUNT = 1;\nconst MAX_CHANNEL_COUNT = 56;\nconst MIN_PIXEL = 1;\n\nexport type FileHeaderSection = {\n  version: PsdVersion;\n  channelCount: number;\n  width: number;\n  height: number;\n  depth: Depth;\n  colorMode: ColorMode;\n};\n\nexport function parseFileHeader(dataView: DataView): FileHeaderSection {\n  const cursor = new Cursor(dataView);\n\n  const signature = cursor.take(4);\n  if (!equals(signature, EXPECTED_SIGNATURE)) {\n    throw new InvalidSignature();\n  }\n\n  const version = cursor.read(\"u16\");\n  if (!(version === PsdVersion.PSD || version === PsdVersion.PSB)) {\n    throw new InvalidVersion();\n  }\n  const fileVersionSpec = getFileVersionSpec(version);\n\n  const reserved = cursor.take(6);\n  if (!equals(reserved, EXPECTED_RESERVED)) {\n    throw new InvalidReservationCode();\n  }\n\n  const channelCount = cursor.read(\"u16\");\n  if (!inRange(channelCount, MIN_CHANNEL_COUNT, MAX_CHANNEL_COUNT)) {\n    throw new InvalidChannelCount();\n  }\n\n  const height = cursor.read(\"u32\");\n  const width = cursor.read(\"u32\");\n  if (\n    !inRange(height, MIN_PIXEL, fileVersionSpec.maxPixels) ||\n    !inRange(width, MIN_PIXEL, fileVersionSpec.maxPixels)\n  ) {\n    throw new InvalidPixelCount();\n  }\n\n  const depth = cursor.read(\"u16\");\n  if (!EXPECTED_DEPTH_KINDS.includes(depth)) {\n    throw new InvalidDepth();\n  }\n\n  const colorMode = cursor.read(\"u16\");\n  if (colorMode in ColorMode === false) {\n    throw new InvalidColorMode();\n  }\n\n  return {\n    channelCount,\n    version,\n    width,\n    height,\n    depth,\n    colorMode,\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {Depth} from \"../../interfaces\";\nimport {Cursor, UnsupportedDepth} from \"../../utils\";\n\nexport function readRawData(\n  cursor: Cursor,\n  depth: Depth,\n  channelCount: number\n) {\n  // First 2 bytes were compression bytes\n  const bytesCountPerChannel = (cursor.length - 2) / channelCount;\n\n  const red = cursor.extract(bytesCountPerChannel);\n  const green =\n    channelCount >= 2 ? cursor.extract(bytesCountPerChannel) : undefined;\n  const blue =\n    channelCount >= 3 ? cursor.extract(bytesCountPerChannel) : undefined;\n  const alpha =\n    channelCount >= 4 ? cursor.extract(bytesCountPerChannel) : undefined;\n\n  if (depth === Depth.Eight) {\n    return {red, green, blue, alpha};\n  } else {\n    throw new UnsupportedDepth(`Unsupported image bit depth: ${depth}`);\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {FileVersionSpec} from \"../../interfaces\";\nimport {Cursor} from \"../../utils\";\n\nexport function readRleCompressedData(\n  cursor: Cursor,\n  channelCount: number,\n  height: number,\n  fileVersionSpec: FileVersionSpec\n) {\n  let redByteCount = 0,\n    greenByteCount = 0,\n    blueByteCount = 0,\n    alphaByteCount = 0;\n\n  const byteCountReadType = fileVersionSpec.rleScanlineLengthFieldReadType;\n  for (let i = 0; i < height; i++) {\n    redByteCount += cursor.read(byteCountReadType);\n  }\n\n  if (channelCount >= 2) {\n    for (let i = 0; i < height; i++) {\n      greenByteCount += cursor.read(byteCountReadType);\n    }\n  }\n\n  if (channelCount >= 3) {\n    for (let i = 0; i < height; i++) {\n      blueByteCount += cursor.read(byteCountReadType);\n    }\n  }\n\n  if (channelCount === 4) {\n    for (let i = 0; i < height; i++) {\n      alphaByteCount += cursor.read(byteCountReadType);\n    }\n  }\n\n  const channelDataStart =\n    2 + channelCount * height * fileVersionSpec.rleScanlineLengthFieldSize;\n  const _cursor = cursor.clone(channelDataStart);\n\n  const red = _cursor.take(redByteCount);\n  const green = greenByteCount ? _cursor.take(greenByteCount) : undefined;\n  const blue = blueByteCount ? _cursor.take(blueByteCount) : undefined;\n  const alpha = alphaByteCount ? _cursor.take(alphaByteCount) : undefined;\n\n  return {red, green, blue, alpha};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ChannelCompression, Depth, FileVersionSpec} from \"../../interfaces\";\nimport {Cursor, InvalidCompression, UnsupportedCompression} from \"../../utils\";\nimport {readRawData} from \"./readRawData\";\nimport {readRleCompressedData} from \"./readRleCompressedData\";\n\nexport interface ImageDataSection {\n  compression: ChannelCompression;\n  red: Uint8Array;\n  green?: Uint8Array;\n  blue?: Uint8Array;\n  alpha?: Uint8Array;\n}\n\nexport function parseImageData(\n  dataView: DataView,\n  depth: Depth,\n  height: number,\n  channelCount: number,\n  fileVersionSpec: FileVersionSpec\n): ImageDataSection {\n  const cursor = new Cursor(dataView);\n\n  const compression = cursor.read(\"u16\");\n  if (!(compression in ChannelCompression)) {\n    throw new InvalidCompression();\n  }\n\n  const {red, green, blue, alpha} = (() => {\n    switch (compression) {\n      case ChannelCompression.RawData: {\n        return readRawData(cursor, depth, channelCount);\n      }\n      case ChannelCompression.RleCompressed: {\n        return readRleCompressedData(\n          cursor,\n          channelCount,\n          height,\n          fileVersionSpec\n        );\n      }\n      default: {\n        throw new UnsupportedCompression();\n      }\n    }\n  })();\n\n  return {\n    compression,\n    red,\n    green,\n    blue,\n    alpha,\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  GridAndGuidesResourceBlock,\n  Guide,\n  matchGuideDirection,\n} from \"../../interfaces\";\nimport {Cursor, InvalidGridAndGuidesVersion} from \"../../utils\";\n\nexport function readGridAndGuides(\n  cursor: Cursor\n): GridAndGuidesResourceBlock[\"resource\"] {\n  const version = cursor.read(\"u32\");\n  if (version !== 1) {\n    throw new InvalidGridAndGuidesVersion();\n  }\n\n  const gridSizeX = cursor.read(\"u32\");\n  const gridSizeY = cursor.read(\"u32\");\n\n  const guideCount = cursor.read(\"u32\");\n\n  const guides: Guide[] = [];\n  for (let i = 0; i < guideCount; ++i) {\n    const position = cursor.read(\"i32\");\n    const direction = matchGuideDirection(cursor.read(\"u8\"));\n\n    guides.push({position, direction});\n  }\n\n  return {version, gridSizeX, gridSizeY, guides};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ICCProfileResourceBlock} from \"../../interfaces\";\nimport {Cursor} from \"../../utils\";\n\nexport function readICCProfile(\n  cursor: Cursor,\n  expectedEndPos: number\n): ICCProfileResourceBlock[\"resource\"] {\n  return cursor.take(expectedEndPos - cursor.position);\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ResolutionInfoResourceBlock} from \"../../interfaces\";\nimport {Cursor} from \"../../utils\";\n\nexport function readResolutionInfo(\n  cursor: Cursor\n): ResolutionInfoResourceBlock[\"resource\"] {\n  const horizontal = cursor.readFixedPoint32bit();\n  const horizontalUnit = cursor.read(\"u16\");\n  const widthUnit = cursor.read(\"u16\");\n\n  const vertical = cursor.readFixedPoint32bit();\n  const verticalUnit = cursor.read(\"u16\");\n  const heightUnit = cursor.read(\"u16\");\n\n  return {\n    horizontal,\n    horizontalUnit,\n    widthUnit,\n    vertical,\n    verticalUnit,\n    heightUnit,\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {readVersionedDescriptor} from \"../../methods\";\nimport {\n  matchSliceOrigin,\n  SliceEntry,\n  SlicesResourceBlock,\n} from \"../../interfaces\";\nimport {Cursor, InvalidSlicesVersion} from \"../../utils\";\n\nexport function readSlices(\n  cursor: Cursor,\n  expectedEndPos: number\n): SlicesResourceBlock[\"resource\"] {\n  const version = cursor.read(\"u32\");\n\n  if (version === 6) {\n    const boundTop = cursor.read(\"i32\");\n    const boundLeft = cursor.read(\"i32\");\n    const boundBottom = cursor.read(\"i32\");\n    const boundRight = cursor.read(\"i32\");\n    const sliceGroupName = cursor.readUnicodeString(0);\n\n    const sliceCount = cursor.read(\"u32\");\n    const slices: SliceEntry[] = [];\n    while (slices.length < sliceCount) {\n      const id = cursor.read(\"u32\");\n      const groupId = cursor.read(\"u32\");\n      const origin = matchSliceOrigin(cursor.read(\"u32\"));\n      const associatedLayerId = origin === 1 ? cursor.read(\"u32\") : undefined;\n      slices.push({\n        id,\n        groupId,\n        origin,\n        associatedLayerId,\n        name: cursor.readUnicodeString(0),\n        type: cursor.read(\"u32\"),\n        left: cursor.read(\"i32\"),\n        top: cursor.read(\"i32\"),\n        right: cursor.read(\"i32\"),\n        bottom: cursor.read(\"i32\"),\n        url: cursor.readUnicodeString(0),\n        target: cursor.readUnicodeString(0),\n        message: cursor.readUnicodeString(0),\n        altTag: cursor.readUnicodeString(0),\n        isCellTextHtml: Boolean(cursor.read(\"u8\")),\n        cellText: cursor.readUnicodeString(0),\n        horizontalAlignment: cursor.read(\"i32\"),\n        verticalAlignment: cursor.read(\"i32\"),\n        alpha: cursor.read(\"u8\"),\n        red: cursor.read(\"u8\"),\n        green: cursor.read(\"u8\"),\n        blue: cursor.read(\"u8\"),\n      });\n    }\n\n    const descriptor =\n      cursor.position < expectedEndPos\n        ? readVersionedDescriptor(cursor)\n        : undefined;\n\n    return {\n      version,\n      boundTop,\n      boundLeft,\n      boundBottom,\n      boundRight,\n      sliceGroupName,\n      slices,\n      descriptor,\n    };\n  } else if (version === 7 || version === 8) {\n    const descriptor = readVersionedDescriptor(cursor);\n    return {version, descriptor};\n  } else {\n    throw new InvalidSlicesVersion(\n      `Invalid Slices section version: ${version}`\n    );\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ImageResourceBlock, ResourceType} from \"../../interfaces\";\nimport {Cursor, equals, InvalidResourceSignature} from \"../../utils\";\nimport {readGridAndGuides} from \"./readGridAndGuides\";\nimport {readICCProfile} from \"./readICCProfile\";\nimport {readResolutionInfo} from \"./readResolutionInfo\";\nimport {readSlices} from \"./readSlices\";\n\nconst EXPECTED_RESOURCE_BLOCK_SIGNATURE = [56, 66, 73, 77];\n\nexport type ImageResourcesSection = {\n  resources: ImageResourceBlock[];\n};\n\nexport function parseImageResource(dataView: DataView): ImageResourcesSection {\n  const cursor = new Cursor(dataView);\n  const resources: ImageResourceBlock[] = [];\n\n  const length = cursor.read(\"u32\");\n  while (cursor.position < length) {\n    const block = readResourceBlock(cursor);\n\n    resources.push(block);\n  }\n\n  return {resources};\n}\n\nfunction readResourceBlock(cursor: Cursor): ImageResourceBlock {\n  const signature = cursor.take(4);\n  if (!equals(signature, EXPECTED_RESOURCE_BLOCK_SIGNATURE)) {\n    throw new InvalidResourceSignature();\n  }\n\n  const id = cursor.read(\"i16\");\n  const name = readPascalString(cursor, 2);\n\n  const dataLength = cursor.read(\"u32\");\n  const expectedDataEnd = cursor.position + dataLength;\n  // Note: data length is padded to even.\n  const paddedDataLength = dataLength + (dataLength % 2);\n\n  const dataBegin = cursor.position;\n\n  let resource: ImageResourceBlock[\"resource\"] = null;\n\n  switch (id) {\n    case ResourceType.GridAndGuides:\n      resource = readGridAndGuides(cursor);\n      break;\n    case ResourceType.Slices:\n      resource = readSlices(cursor, expectedDataEnd);\n      break;\n    case ResourceType.ICCProfile:\n      resource = readICCProfile(cursor, expectedDataEnd);\n      break;\n    case ResourceType.ResolutionInfo:\n      resource = readResolutionInfo(cursor);\n      break;\n    case ResourceType.GlobalLightAltitude:\n      resource = cursor.read(\"i32\");\n      break;\n    case ResourceType.GlobalLightAngle:\n      resource = cursor.read(\"i32\");\n      break;\n    default:\n    // For now, ignore resource types that we don't support;\n    // there are too many, and we can't support all of them now.\n  }\n\n  const dataEnd = cursor.position;\n  const remainingBytes = dataBegin + paddedDataLength - dataEnd;\n  if (remainingBytes > 0) {\n    cursor.pass(remainingBytes);\n  }\n\n  return {id, name, resource};\n}\n\n/**\n * Parses a \"Pascal string\", as described in Adobe's documentation.\n * A Pascal string is structured as:\n *\n * | Size (bytes) |         Content        |\n * |--------------|------------------------|\n * | 1            | Length                 |\n * | 0 ~ 255      | Characters             |\n * | 0 ~ ?        | Alignment (whitespace) |\n *\n * If {@link alignment} is provided, this function _may_ skip alignment bytes\n * until the total of (length field) + (characters) + (alignment) is a multiple\n * of the `alignment` value.\n * If `alignment` is unspecified or 0, no alignment bytes are skipped.\n */\nfunction readPascalString(cursor: Cursor, alignment = 0): string {\n  const length = cursor.read(\"u8\");\n  const value = cursor.readString(length);\n\n  if (alignment) {\n    const remainder = (length + 1) % alignment;\n    if (remainder > 0) {\n      cursor.pass(alignment - remainder);\n    }\n  }\n\n  return value;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  AdditionalLayerInfo,\n  BlendMode,\n  ChannelBytes,\n  ChannelKind,\n  Clipping,\n  EngineData,\n  GroupDivider,\n} from \"../../interfaces\";\n\nexport interface LayerRecord {\n  name: string;\n  channelInformation: [ChannelKind, number][];\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  hidden: boolean;\n  transparencyLocked: boolean;\n  opacity: number;\n  clipping: Clipping;\n  blendMode: BlendMode;\n  additionalLayerInfos: AdditionalLayerInfo[];\n  // The following properties are extracted from the additionalLayerInfos field\n  // for easy access\n  /** If defined, divider type for \"group divider\" layers. */\n  dividerType?: GroupDivider;\n  /** If defined, contains the text of a Text Layer. */\n  layerText?: string;\n  /** If defined, containts extra text properties */\n  engineData?: EngineData;\n  maskData: MaskData;\n}\n\nexport type LayerChannels = Map<ChannelKind, ChannelBytes>;\n\nexport interface Frame {\n  startIndex: number;\n  groupId: number;\n  parentGroupId: number;\n  layerRecord?: LayerRecord;\n}\n\nexport type AdditionalLayerProperties = AdditionalLayerInfo[];\n\nexport interface LayerProperties {\n  name: string;\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  hidden: boolean;\n  transparencyLocked: boolean;\n  opacity: number;\n  clippingMask: Clipping;\n  blendMode: BlendMode;\n  groupId?: number;\n  /** Text content of text layers */\n  text?: string;\n  /** Text properties */\n  textProperties?: EngineData;\n  maskData: MaskData;\n  additionalLayerProperties: AdditionalLayerProperties;\n}\n\nexport const createLayerProperties = (\n  name: string,\n  layerRecord: LayerRecord,\n  groupId?: number\n): LayerProperties => {\n  const {\n    top,\n    left,\n    bottom,\n    right,\n    opacity,\n    clipping: clippingMask,\n    hidden,\n    transparencyLocked,\n    blendMode,\n    layerText,\n    engineData,\n    maskData,\n    additionalLayerInfos,\n  } = layerRecord;\n\n  return {\n    name,\n    top,\n    left,\n    bottom,\n    right,\n    opacity,\n    clippingMask,\n    hidden,\n    transparencyLocked,\n    blendMode,\n    groupId,\n    text: layerText,\n    textProperties: engineData,\n    maskData,\n    additionalLayerProperties: additionalLayerInfos,\n  };\n};\n\nexport interface MaskFlags {\n  // bit 0 = position relative to layer\n  positionRelativeToLayer: boolean;\n  // bit 1 = layer mask disabled\n  layerMaskDisabled: boolean;\n  // bit 2 = invert layer mask when blending (Obsolete)\n  invertMaskWhenBlending: boolean;\n  // bit 3 = indicates that the user mask actually came from rendering other data\n  userMaskFromRenderingOtherData: boolean;\n  // bit 4 = indicates that the user and/or vector masks have parameters applied to them\n  masksHaveParametersApplied: boolean;\n}\n\nexport interface MaskParameters {\n  // bit 0 = user mask density, 1 byte\n  userMaskDensity?: number;\n  // bit 1 = user mask feather, 8 byte, double\n  userMaskFeather?: number;\n  // bit 2 = vector mask density, 1 byte\n  vectorMaskDensity?: number;\n  // bit 3 = vector mask feather, 8 bytes, double\n  vectorMaskFeather?: number;\n}\n\n// The spec is confusing at best... what \"real\" means?\n// https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1031423\nexport interface RealMaskData {\n  flags: MaskFlags;\n  backgroundColor: number;\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n}\n\nexport interface MaskData {\n  top: number;\n  left: number;\n  bottom: number;\n  right: number;\n  backgroundColor: number;\n  flags: MaskFlags;\n  parameters?: MaskParameters;\n  // only present if size != 20\n  realData?: RealMaskData;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ChannelKind, ChannelBytes} from \"../../interfaces\";\nimport {ChannelNotFound} from \"../../utils\";\nimport {\n  LayerRecord,\n  LayerChannels,\n  LayerProperties,\n  createLayerProperties,\n} from \"./interfaces\";\n\nexport class LayerFrame {\n  static create(\n    layerRecord: LayerRecord,\n    channels: LayerChannels,\n    groupId?: number\n  ): LayerFrame {\n    const layerProperties = createLayerProperties(\n      layerRecord.name,\n      layerRecord,\n      groupId\n    );\n\n    return new LayerFrame(channels, layerProperties);\n  }\n\n  constructor(\n    public readonly channels: LayerChannels,\n    public readonly layerProperties: LayerProperties\n  ) {}\n\n  get red(): ChannelBytes {\n    const channelBytes = this.channels.get(ChannelKind.Red);\n    if (channelBytes === undefined) {\n      throw new ChannelNotFound();\n    }\n\n    return channelBytes;\n  }\n  get green(): ChannelBytes | undefined {\n    return this.channels.get(ChannelKind.Green);\n  }\n  get blue(): ChannelBytes | undefined {\n    return this.channels.get(ChannelKind.Blue);\n  }\n  get alpha(): ChannelBytes | undefined {\n    return this.channels.get(ChannelKind.TransparencyMask);\n  }\n  get userMask(): ChannelBytes | undefined {\n    return this.channels.get(ChannelKind.UserSuppliedLayerMask);\n  }\n  get realUserMask(): ChannelBytes | undefined {\n    return this.channels.get(ChannelKind.RealUserSuppliedLayerMask);\n  }\n\n  get width(): number {\n    const {right, left} = this.layerProperties;\n    return right - left + 1;\n  }\n  get height(): number {\n    const {bottom, top} = this.layerProperties;\n    return bottom - top + 1;\n  }\n}\n\nexport class GroupFrame {\n  static create(\n    name: string,\n    id: number,\n    layerRecord: LayerRecord,\n    groupId?: number\n  ): GroupFrame {\n    const layerProperties = createLayerProperties(name, layerRecord, groupId);\n\n    return new GroupFrame(id, layerProperties);\n  }\n\n  constructor(\n    public readonly id: number,\n    public readonly layerProperties: LayerProperties\n  ) {}\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ArtboardDataAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readArtboardDataAliBlock(\n  cursor: Cursor\n): AliBlockBody<ArtboardDataAliBlock> {\n  const data = readVersionedDescriptor(cursor);\n  return {data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {BlendOptionsCapacityAliBlock} from \"../../../interfaces\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readBlendOptionsCapacityAliBlock(\n  cursor: Cursor\n): AliBlockBody<BlendOptionsCapacityAliBlock> {\n  const fillOpacity = cursor.read(\"u8\");\n  return {fillOpacity};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {GradientFillSettingAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readGradientFillSettingAliBlock(\n  cursor: Cursor\n): AliBlockBody<GradientFillSettingAliBlock> {\n  const data = readVersionedDescriptor(cursor);\n  return {data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {HSLChange, HSLValue, HueSaturationAliBlock} from \"../../../interfaces\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nfunction readHSL(cursor: Cursor): HSLValue {\n  const hue = cursor.read(\"i16\");\n  const saturation = cursor.read(\"i16\");\n  const lightness = cursor.read(\"i16\");\n  return {\n    hue,\n    saturation,\n    lightness,\n  };\n}\n\nfunction readHSLChange(cursor: Cursor): HSLChange {\n  const beginRamp = cursor.read(\"i16\");\n  const beginSustain = cursor.read(\"i16\");\n  const endSustain = cursor.read(\"i16\");\n  const endRamp = cursor.read(\"i16\");\n  return {\n    beginRamp,\n    beginSustain,\n    endSustain,\n    endRamp,\n    ...readHSL(cursor),\n  };\n}\n\nfunction readAdjustment(cursor: Cursor): HSLChange[] {\n  return Array.from(Array(6), () => readHSLChange(cursor));\n}\n\nexport function readHueSaturationAliBlock(\n  cursor: Cursor\n): AliBlockBody<HueSaturationAliBlock> {\n  const version = cursor.read(\"u16\");\n  const colorize = cursor.read(\"u8\");\n  cursor.pass(1);\n  const colorization = readHSL(cursor);\n  const master = readHSL(cursor);\n  return {\n    version,\n    colorize,\n    colorization,\n    master,\n    adjustment: colorize ? undefined : readAdjustment(cursor),\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {LayerIdAliBlock} from \"../../../interfaces\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readLayerIdAliBlock(\n  cursor: Cursor\n): AliBlockBody<LayerIdAliBlock> {\n  const value = cursor.read(\"u32\");\n  return {value};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {LinkedLayer, LinkedLayerAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor, InvalidLinkedLayerType} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readLinkedLayerAliBlock(\n  cursor: Cursor,\n  size: number\n): AliBlockBody<LinkedLayerAliBlock> {\n  const layers = [];\n  let nextFileLength = 0;\n  const endAt = cursor.position + size;\n  while (cursor.position < endAt && (nextFileLength = cursor.read(\"u64\"))) {\n    const position = cursor.position;\n    const layer = readLayer(cursor);\n    layers.push(layer);\n    const advancedSoFar = cursor.position - position;\n    const undocumentedDataLength = nextFileLength - advancedSoFar;\n    cursor.pass(undocumentedDataLength);\n    cursor.padding(cursor.position, 4);\n  }\n  return {layers};\n}\n\nfunction readLayer(cursor: Cursor): LinkedLayer {\n  const layerType = cursor.readString(4);\n  if (layerType !== \"liFD\") {\n    throw new InvalidLinkedLayerType(`unknown layer type: '${layerType}'`);\n  }\n\n  const version = cursor.read(\"i32\");\n  const uniqueId = readUniqueId(cursor);\n  const filename = cursor.readUnicodeString(0);\n  const filetype = cursor.readString(4);\n  const creator = cursor.readString(4);\n  const filelength = cursor.read(\"u64\");\n  const haveFileOpenDescriptor = cursor.read(\"u8\");\n  const data = haveFileOpenDescriptor\n    ? readVersionedDescriptor(cursor)\n    : undefined;\n  const contents = cursor.take(filelength);\n  const uuid = version > 5 ? cursor.readUnicodeString() : undefined;\n  return {\n    layerType,\n    version,\n    uniqueId,\n    filename,\n    filetype,\n    creator,\n    data,\n    contents,\n    uuid,\n  };\n}\n\nfunction readUniqueId(cursor: Cursor): string {\n  const uniqueIDLength = cursor.read(\"u8\");\n  return cursor.readString(uniqueIDLength);\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ObjectBasedEffectsAliBlock} from \"../../../interfaces\";\nimport {readDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readObjectBasedEffectsAliBlock(\n  cursor: Cursor\n): AliBlockBody<ObjectBasedEffectsAliBlock> {\n  const version = cursor.read(\"u32\");\n  const descriptorVersion = cursor.read(\"u32\");\n  const descriptor = readDescriptor(cursor);\n  return {version, descriptor, descriptorVersion};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {PatternFillSettingAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readPatternFillSettingAliBlock(\n  cursor: Cursor\n): AliBlockBody<PatternFillSettingAliBlock> {\n  const data = readVersionedDescriptor(cursor);\n  return {data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  matchBlendMode,\n  matchDividerType,\n  SectionDividerSettingAliBlock,\n  SectionDividerSubtype,\n} from \"../../../interfaces\";\nimport {Cursor, InvalidSectionDividerSetting} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\n/**\n * Parses a partial {@link SectionDividerSettingAliBlock} from the current\n * {@link cursor} position.\n * @param cursor\n * @param size Size of the current ALI block\n */\nexport function readSectionDividerSettingAliBlock(\n  cursor: Cursor,\n  size: number\n): AliBlockBody<SectionDividerSettingAliBlock> {\n  const dividerType = matchDividerType(cursor.read(\"u32\"));\n\n  if (size < 12) {\n    return {dividerType};\n  }\n\n  const dividerSignature = cursor.readString(4);\n  if (dividerSignature !== \"8BIM\") {\n    throw new InvalidSectionDividerSetting(\n      `Invalid Section Divider Setting signature: ${dividerSignature}`\n    );\n  }\n\n  const blendMode = matchBlendMode(cursor.readString(4));\n\n  if (size < 16) {\n    return {dividerType, dividerSignature, blendMode};\n  }\n\n  const subType = cursor.read(\"u32\");\n  if (!(subType in SectionDividerSubtype)) {\n    throw new InvalidSectionDividerSetting(\n      `Invalid Section Divider Setting subtype: ${subType}`\n    );\n  }\n\n  return {dividerType, dividerSignature, blendMode, subType};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {SmartObjectPlacedLayerDataAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readSmartObjectPlacedLayerDataAliBlock(\n  cursor: Cursor\n): AliBlockBody<SmartObjectPlacedLayerDataAliBlock> {\n  const identifier = cursor.readString(4);\n  const version = cursor.read(\"u32\");\n  const data = readVersionedDescriptor(cursor);\n  return {data, version, identifier};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {SolidColorSheetSettingAliBlock} from \"../../../interfaces\";\nimport {readDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readSolidColorSheetSettingAliBlock(\n  cursor: Cursor\n): AliBlockBody<SolidColorSheetSettingAliBlock> {\n  const version = cursor.read(\"u32\");\n  const data = readDescriptor(cursor);\n\n  return {version, data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {TypeToolObjectSettingAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor, InvalidTypeToolObjectSetting} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\n/**\n * Parses a partial {@link TypeToolObjectSettingAliBlock} from the current\n * {@link cursor} position.\n * @param cursor\n */\nexport function readTypeToolObjectSettingAliBlock(\n  cursor: Cursor\n): AliBlockBody<TypeToolObjectSettingAliBlock> {\n  const version = cursor.read(\"u16\");\n  if (version !== 1) {\n    throw new InvalidTypeToolObjectSetting(\n      `Invalid type tool object setting version: ${version}`\n    );\n  }\n\n  const transformXX = cursor.read(\"f64\");\n  const transformXY = cursor.read(\"f64\");\n  const transformYX = cursor.read(\"f64\");\n  const transformYY = cursor.read(\"f64\");\n  const transformTX = cursor.read(\"f64\");\n  const transformTY = cursor.read(\"f64\");\n\n  const textVersion = cursor.read(\"u16\");\n  if (textVersion !== 50) {\n    throw new InvalidTypeToolObjectSetting(\n      `Invalid text version: ${textVersion}`\n    );\n  }\n\n  const textData = readVersionedDescriptor(cursor);\n\n  const warpVersion = cursor.read(\"u16\");\n  if (warpVersion !== 1) {\n    throw new InvalidTypeToolObjectSetting(\n      `Invalid warp version: ${warpVersion}`\n    );\n  }\n\n  const warpData = readVersionedDescriptor(cursor);\n\n  const left = cursor.read(\"f64\");\n  const top = cursor.read(\"f64\");\n  const right = cursor.read(\"f64\");\n  const bottom = cursor.read(\"f64\");\n\n  return {\n    version,\n    transformXX,\n    transformXY,\n    transformYX,\n    transformYY,\n    transformTX,\n    transformTY,\n    textVersion,\n    textData,\n    warpVersion,\n    warpData,\n    left,\n    top,\n    right,\n    bottom,\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {UnicodeLayerNameAliBlock} from \"../../../interfaces\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\n/**\n * Parses a partial {@link UnicodeLayerNameAliBlock} from the current\n * {@link cursor} position.\n * @param cursor\n */\nexport function readUnicodeLayerNameAliBlock(\n  cursor: Cursor\n): AliBlockBody<UnicodeLayerNameAliBlock> {\n  const name = cursor.readUnicodeString(0);\n  return {name};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  PathRecord,\n  PathRecordType,\n  Point,\n  VectorMaskSettingAliBlock,\n} from \"../../../interfaces\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\n/**\n * Reads signed 32-bit fixed-point number with 8bits.24bits.\n * https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_17587\n *  All points used in defining a path are stored in eight bytes as a pair of\n *  32-bit components, vertical component first.\n *  The two components are signed, fixed point numbers with 8 bits before the binary\n *  point and 24 bits after the binary point. Three guard bits are reserved in the\n *  points to eliminate most concerns over arithmetic overflow. Hence, the range for\n *  each component is 0xF0000000 to 0x0FFFFFFF representing a range of -16 to 16.\n *  The lower bound is included, but not the upper bound.\n\n *  This limited range is used because the points are expressed relative to the\n *  image size. The vertical component is given with respect to the image height,\n *  and the horizontal component is given with respect to the image width. [ 0,0 ]\n *  represents the top-left corner of the image; [ 1,1 ] ([ 0x01000000,0x01000000 ])\n *  represents the bottom-right.\n */\nfunction readFixedPoint32bit(cursor: Cursor): number {\n  const [beforeValue, ...afterPoint] = cursor.take(4);\n  const afterValue =\n    afterPoint[0] * 2 ** 16 + afterPoint[1] * 2 ** 8 + afterPoint[2];\n  return beforeValue + afterValue / 2 ** 24;\n}\n\nfunction readPoint(cursor: Cursor): Point {\n  const vert = readFixedPoint32bit(cursor);\n  const horiz = readFixedPoint32bit(cursor);\n  return {vert, horiz};\n}\n\nfunction readSubpath(cursor: Cursor, type: number): PathRecord {\n  const length = cursor.read(\"i16\");\n  const operation = cursor.read(\"i16\");\n  const subpathType = cursor.read(\"i16\");\n  cursor.pass(6);\n  const index = cursor.read(\"i16\");\n  cursor.pass(10);\n  return {\n    type,\n    length,\n    operation,\n    subpathType,\n    index,\n  };\n}\n\nfunction readClipboard(cursor: Cursor, type: number): PathRecord {\n  const bounds = Array(4).map(() => cursor.read(\"f32\")) as [\n    number,\n    number,\n    number,\n    number\n  ];\n  const resolution = cursor.read(\"f32\");\n  cursor.pass(6);\n  return {type, bounds, resolution};\n}\n\nfunction readFillRule(cursor: Cursor, type: number): PathRecord {\n  const fill = Boolean(cursor.read(\"i16\") & 1);\n  cursor.pass(22);\n  return {type, fill};\n}\n\nfunction readBezierKnot(cursor: Cursor, type: number): PathRecord {\n  const preceding = readPoint(cursor);\n  const anchor = readPoint(cursor);\n  const leaving = readPoint(cursor);\n  return {type, preceding, anchor, leaving};\n}\n\nfunction readPathRecord(cursor: Cursor): PathRecord {\n  const type = cursor.read(\"u16\");\n  switch (type) {\n    case PathRecordType.OpenSubpathLength:\n    case PathRecordType.ClosedSubpathLength:\n      return readSubpath(cursor, type);\n    case PathRecordType.PathFillRule:\n      cursor.pass(24);\n      return {type};\n    case PathRecordType.Clipboard:\n      return readClipboard(cursor, type);\n    case PathRecordType.InitialFillRule:\n      return readFillRule(cursor, type);\n    case PathRecordType.ClosedSubpathBezierKnotLinked:\n    case PathRecordType.ClosedSubpathBezierKnotUnlinked:\n    case PathRecordType.OpenSubpathBezierKnotLinked:\n    case PathRecordType.OpenSubpathBezierKnotUnlinked:\n      return readBezierKnot(cursor, type);\n    default:\n      throw new Error(`Unknown PathRecordType: ${type} (bug in offsets?)`);\n  }\n}\n\nfunction readPathRecords(cursor: Cursor, size: number): PathRecord[] {\n  const count = Math.floor(size / 26);\n  return Array.from(Array(count), () => readPathRecord(cursor));\n}\n\nexport function readVectorMaskSettingAliBlock(\n  cursor: Cursor,\n  size: number\n): AliBlockBody<VectorMaskSettingAliBlock> {\n  const version = cursor.read(\"u32\");\n  const flags = cursor.read(\"u32\");\n  const pathRecords = readPathRecords(cursor, size);\n  return {\n    version,\n    pathRecords,\n    invert: Boolean(flags & 1),\n    notLink: Boolean(flags & 2),\n    disable: Boolean(flags & 4),\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {VectorStrokeContentDataAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readVectorStrokeContentDataAliBlock(\n  cursor: Cursor\n): AliBlockBody<VectorStrokeContentDataAliBlock> {\n  const version = cursor.read(\"u32\");\n  const data = readVersionedDescriptor(cursor);\n  return {version, data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {VectorStrokeDataAliBlock} from \"../../../interfaces\";\nimport {readVersionedDescriptor} from \"../../../methods\";\nimport {Cursor} from \"../../../utils\";\nimport {AliBlockBody} from \"./AliBlockBody\";\n\nexport function readVectorStrokeDataAliBlock(\n  cursor: Cursor\n): AliBlockBody<VectorStrokeDataAliBlock> {\n  const data = readVersionedDescriptor(cursor);\n  return {data};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  AdditionalLayerInfo,\n  AliKey,\n  FileVersionSpec,\n} from \"../../../interfaces\";\nimport {Cursor, InvalidAdditionalLayerInfoSignature} from \"../../../utils\";\nimport {readArtboardDataAliBlock} from \"./readArtboardDataAliBlock\";\nimport {readBlendOptionsCapacityAliBlock} from \"./readBlendOptionsCapacityAliBlock\";\nimport {readGradientFillSettingAliBlock} from \"./readGradientFillSettingAliBlock\";\nimport {readHueSaturationAliBlock} from \"./readHueSaturationAliBlock\";\nimport {readLayerIdAliBlock} from \"./readLayerIdAliBlock\";\nimport {readLinkedLayerAliBlock} from \"./readLinkedLayerAliBlock\";\nimport {readObjectBasedEffectsAliBlock} from \"./readObjectBasedEffectsAliBlock\";\nimport {readPatternFillSettingAliBlock} from \"./readPatternFillSettingAliBlock\";\nimport {readSectionDividerSettingAliBlock} from \"./readSectionDividerSettingAliBlock\";\nimport {readSmartObjectPlacedLayerDataAliBlock} from \"./readSmartObjectPlacedLayerDataAliBlock\";\nimport {readSolidColorSheetSettingAliBlock} from \"./readSolidColorSheetSettingAliBlock\";\nimport {readTypeToolObjectSettingAliBlock} from \"./readTypeToolObjectSettingAliBlock\";\nimport {readUnicodeLayerNameAliBlock} from \"./readUnicodeLayerNameAliBlock\";\nimport {readVectorMaskSettingAliBlock} from \"./readVectorMaskSettingAliBlock\";\nimport {readVectorStrokeContentDataAliBlock} from \"./readVectorStrokeContentDataAliBlock\";\nimport {readVectorStrokeDataAliBlock} from \"./readVectorStrokeDataAliBlock\";\n\n/**\n * Reads a single Additional Layer Information block from the current\n * {@link cursor} position.\n * @param cursor\n * @param fileVersionSpec\n * @param padding - dictates padding of the blocks. See f4fc9497d2826aeaed17910194dc9e8f7130ebe9\n */\nexport function readAdditionalLayerInfo(\n  cursor: Cursor,\n  fileVersionSpec: FileVersionSpec,\n  padding = 0\n): AdditionalLayerInfo {\n  const signature = cursor.readString(4);\n\n  if (signature !== \"8BIM\" && signature !== \"8B64\") {\n    throw new InvalidAdditionalLayerInfoSignature(\n      `Invalid signature: ${signature}`\n    );\n  }\n\n  const key = cursor.readString(4);\n  const size = cursor.read(getAliLengthFieldSizeType(key, fileVersionSpec));\n\n  const prevPosition = cursor.position;\n\n  const aliBlock = readAliBlockBody(cursor, signature, key, size);\n\n  // Position the cursor at the end of the ALI block\n  const remainingBytes = size - (cursor.position - prevPosition);\n  cursor.pass(remainingBytes);\n  cursor.padding(size, padding);\n\n  return aliBlock;\n}\n\n/**\n * Reads an Additional Layer Info block, but does not align the cursor.\n * @param cursor\n * @param key\n * @param size Size of the ALI block body in bytes\n */\nfunction readAliBlockBody(\n  cursor: Cursor,\n  signature: AdditionalLayerInfo[\"signature\"],\n  key: AdditionalLayerInfo[\"key\"],\n  size: number\n): AdditionalLayerInfo {\n  switch (key) {\n    case AliKey.NestedSectionDividerSetting:\n    case AliKey.SectionDividerSetting:\n      return {\n        signature,\n        key,\n        ...readSectionDividerSettingAliBlock(cursor, size),\n      };\n    case AliKey.TypeToolObjectSetting:\n      return {signature, key, ...readTypeToolObjectSettingAliBlock(cursor)};\n    case AliKey.UnicodeLayerName:\n      return {signature, key, ...readUnicodeLayerNameAliBlock(cursor)};\n    case AliKey.VectorStrokeData:\n      return {signature, key, ...readVectorStrokeDataAliBlock(cursor)};\n    case AliKey.ObjectBasedEffects:\n      return {signature, key, ...readObjectBasedEffectsAliBlock(cursor)};\n    case AliKey.GradientFillSetting:\n      return {signature, key, ...readGradientFillSettingAliBlock(cursor)};\n    case AliKey.SolidColorSheetSetting:\n      return {signature, key, ...readSolidColorSheetSettingAliBlock(cursor)};\n    case AliKey.PatternFillSetting:\n      return {signature, key, ...readPatternFillSettingAliBlock(cursor)};\n    case AliKey.VectorStrokeContentData:\n      return {signature, key, ...readVectorStrokeContentDataAliBlock(cursor)};\n    case AliKey.BlendOptionsCapacity:\n      return {signature, key, ...readBlendOptionsCapacityAliBlock(cursor)};\n    case AliKey.VectorMaskSetting1:\n    case AliKey.VectorMaskSetting2:\n      return {signature, key, ...readVectorMaskSettingAliBlock(cursor, size)};\n    case AliKey.HueSaturation:\n      return {signature, key, ...readHueSaturationAliBlock(cursor)};\n    case AliKey.LayerId:\n      return {signature, key, ...readLayerIdAliBlock(cursor)};\n    case AliKey.ArtboardData:\n      return {signature, key, ...readArtboardDataAliBlock(cursor)};\n    case AliKey.PlacedLayerData:\n    case AliKey.SmartObjectPlacedLayerData:\n      return {\n        signature,\n        key,\n        ...readSmartObjectPlacedLayerDataAliBlock(cursor),\n      };\n    case AliKey.LinkedLayer:\n    case AliKey.LinkedLayer2:\n    case AliKey.LinkedLayer3:\n      return {\n        signature,\n        key,\n        ...readLinkedLayerAliBlock(cursor, size),\n      };\n    default: {\n      const data = cursor.take(size);\n      return {signature, key, _isUnknown: true, data};\n    }\n  }\n}\n\nfunction getAliLengthFieldSizeType(\n  key: string,\n  fileVersionSpec: FileVersionSpec\n): \"u32\" | \"u64\" {\n  if (fileVersionSpec.aliLengthFieldSizeIsVariable) {\n    switch (key) {\n      case \"LMsk\":\n      case \"Lr16\":\n      case \"Lr32\":\n      case \"Layr\":\n      case \"Mt16\":\n      case \"Mt32\":\n      case \"Mtrn\":\n      case \"Alph\":\n      case \"FMsk\":\n      case \"Ink2\":\n      case \"FEid\":\n      case \"FXid\":\n      case \"PxSD\":\n      case \"cinf\": // Undocumented in Adobe's docs\n        return \"u64\";\n    }\n  }\n\n  return \"u32\";\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  AdditionalLayerInfo,\n  AliKey,\n  BlendMode,\n  ChannelBytes,\n  ChannelCompression,\n  ChannelKind,\n  Clipping,\n  DescriptorValueType,\n  FileVersionSpec,\n  matchBlendMode,\n  matchChannelCompression,\n  matchClipping,\n} from \"../../interfaces\";\nimport {parseEngineData} from \"../../methods\";\nimport {\n  Cursor,\n  height,\n  InvalidBlendingModeSignature,\n  ReadType,\n} from \"../../utils\";\nimport {readAdditionalLayerInfo} from \"./AdditionalLayerInfo\";\nimport {\n  MaskData,\n  MaskFlags,\n  MaskParameters,\n  RealMaskData,\n  AdditionalLayerProperties,\n  LayerChannels,\n  LayerRecord,\n} from \"./interfaces\";\n\nconst EXPECTED_BLENDING_MODE_SIGNATURE = \"8BIM\";\n\nexport function readLayerRecordsAndChannels(\n  cursor: Cursor,\n  layerCount: number,\n  fileVersionSpec: FileVersionSpec\n): [LayerRecord, LayerChannels][] {\n  const layerRecords: LayerRecord[] = [];\n\n  // Read layer records\n  while (layerRecords.length < layerCount) {\n    layerRecords.push(readLayerRecord(cursor, fileVersionSpec));\n  }\n\n  // Read layer channels\n  const result = layerRecords\n    .map((layerRecord): [LayerRecord, LayerChannels] => {\n      // The channels for each layer are stored in the same order as the layers\n      const channels = readLayerChannels(\n        cursor,\n        layerRecord.channelInformation,\n        layerRecord,\n        fileVersionSpec\n      );\n\n      return [layerRecord, channels];\n    })\n    // Layers are stored in reverse order, so we must reverse it\n    .reverse();\n\n  return result;\n}\n\nfunction readLayerRecord(\n  cursor: Cursor,\n  fileVersionSpec: FileVersionSpec\n): LayerRecord {\n  const [top, left, bottom, right] = readLayerRectangle(cursor);\n  const channelCount = cursor.read(\"u16\");\n\n  // ChannelInformation\n  // 2 bytes = ChannelID\n  // 4 or 8 bytes = ChannelData\n  const channelInformation: [ChannelKind, number][] = [];\n  while (channelInformation.length < channelCount) {\n    const channelId = cursor.read(\"i16\");\n    if (!(channelId in ChannelKind)) {\n      // Normally, we should throw an exception here.\n      // However, a PSD file saved without \"Compatibility Mode\" checked contains\n      // a channel with an ID of 3, which causes this code to fail.\n      // Since parsing channel IDs -1, 0, 1, and 2 are sufficient to construct\n      // the image, let's ignore channels that we don't know how to handle.\n      // TODO: I suspect that channel #3 is the transparency mask. If so, we can\n      // fix this code to properly parse channel #3 and throw the exception for\n      // unhandleable channels.\n      // throw new InvalidChannel();\n    }\n\n    const channelKind = channelId as ChannelKind;\n    const channelLength = cursor.read(\n      fileVersionSpec.layerRecordSectionChannelLengthFieldReadType\n    );\n\n    // The first two bytes in the channel data stores the compression type;\n    // the remaining length is the length of the channel data.\n    const channelDataLength = channelLength - 2;\n\n    channelInformation.push([channelKind, channelDataLength]);\n  }\n\n  // BlendMode signature '8BIM'\n  if (cursor.readString(4) !== EXPECTED_BLENDING_MODE_SIGNATURE) {\n    throw new InvalidBlendingModeSignature();\n  }\n\n  const blendMode: BlendMode = matchBlendMode(cursor.readString(4));\n  const opacity = cursor.read(\"u8\");\n  const clipping: Clipping = matchClipping(cursor.read(\"u8\"));\n  const {hidden, transparencyLocked} = readLayerFlags(cursor);\n\n  // Skip parsing filter information\n  cursor.pass(1);\n\n  // Length of the Layer Extra Data block, which contains:\n  // Layer Mask / Blending Range / Layer Name\n  const layerExtraDataSize = cursor.read(\"u32\");\n  const layerExtraDataBegin = cursor.position;\n\n  const maskData = readMaskData(cursor);\n\n  // Skip the Blending Range segment, which we don't need for now\n  // Read the length of the segment and skip it\n  cursor.pass(cursor.read(\"u32\"));\n\n  // Parse the Layer Name\n  const nameLength = cursor.read(\"u8\");\n  let name = cursor.readString(nameLength);\n\n  // Layer name is padded to the next multiple of 4 bytes.\n  // So if the name length is 9, there will be three throwaway bytes\n  // after it.\n  //\n  // The 1 is the 1 byte that we read for the name length\n  cursor.padding(nameLength + 1, 4);\n\n  const additionalLayerInfos: AdditionalLayerInfo[] = [];\n  while (cursor.position - layerExtraDataBegin < layerExtraDataSize) {\n    additionalLayerInfos.push(readAdditionalLayerInfo(cursor, fileVersionSpec));\n  }\n\n  // Extract useful information from additionalLayerInfos and expose them as\n  // properties on the LayerRecord object\n  let dividerType: LayerRecord[\"dividerType\"];\n  let layerText: LayerRecord[\"layerText\"];\n  let engineData: LayerRecord[\"engineData\"];\n\n  for (const ali of additionalLayerInfos) {\n    if (ali._isUnknown) continue;\n\n    switch (ali.key) {\n      case AliKey.SectionDividerSetting:\n        ({dividerType} = ali);\n        break;\n      case AliKey.TypeToolObjectSetting: {\n        const textValue = ali.textData.descriptor.items.get(\"Txt \");\n        if (textValue && textValue.type === DescriptorValueType.String) {\n          layerText = textValue.value;\n        }\n        const rawEngineData = ali.textData.descriptor.items.get(\"EngineData\");\n        if (\n          rawEngineData &&\n          rawEngineData.type === DescriptorValueType.RawData\n        ) {\n          engineData = parseEngineData(rawEngineData.data);\n        }\n        break;\n      }\n      case AliKey.UnicodeLayerName:\n        // Use unicode name instead of ASCII name\n        ({name} = ali);\n        break;\n    }\n  }\n\n  return {\n    name,\n    channelInformation,\n    top,\n    left,\n    bottom,\n    right,\n    hidden,\n    transparencyLocked,\n    opacity,\n    clipping,\n    blendMode,\n    additionalLayerInfos,\n    dividerType,\n    layerText,\n    engineData,\n    maskData,\n  };\n}\n\nexport function readGlobalAdditionalLayerInformation(\n  cursor: Cursor,\n  fileVersionSpec: FileVersionSpec\n): AdditionalLayerProperties {\n  const additionalLayerInfos = [];\n  while (cursor.position < cursor.length) {\n    additionalLayerInfos.push(\n      readAdditionalLayerInfo(cursor, fileVersionSpec, /* padding */ 4)\n    );\n  }\n\n  return additionalLayerInfos;\n}\n\nfunction readLayerRectangle(cursor: Cursor): [number, number, number, number] {\n  const top = cursor.read(\"i32\");\n  const left = cursor.read(\"i32\");\n\n  // Subtract 1 to make the offset start at 0.\n  // However, when the layer is completely transparent, the `bottom` value is\n  // already 0, so we don't need to subtract 1.\n  let bottom = cursor.read(\"i32\");\n  if (bottom !== 0) {\n    bottom -= 1;\n  }\n\n  // Subtract 1 to make the offset start at 0.\n  // However, when the layer is completely transparent, the `right` value is\n  // already 0, so we don't need to subtract 1.\n  let right = cursor.read(\"i32\");\n  if (right !== 0) {\n    right -= 1;\n  }\n\n  return [top, left, bottom, right];\n}\n\nfunction readLayerFlags(cursor: Cursor): {\n  hidden: boolean;\n  transparencyLocked: boolean;\n} {\n  const flags = cursor.read(\"u8\");\n  return {\n    transparencyLocked: Boolean(flags & 0x1),\n    // Adobe's docs say this means \"visible\", but this actually marks \"hidden\" layers\n    hidden: Boolean(flags & 0x2),\n  };\n}\n\nfunction realMask(layerRecord: LayerRecord): MaskData {\n  const maskData = layerRecord.maskData.realData;\n  if (!maskData) {\n    throw new Error(\"missing real mask data\");\n  }\n  return maskData;\n}\n\nfunction calcLayerHeight(\n  layerRecord: LayerRecord,\n  channelId: ChannelKind\n): number {\n  switch (channelId) {\n    case ChannelKind.UserSuppliedLayerMask:\n      return height(layerRecord.maskData);\n    case ChannelKind.RealUserSuppliedLayerMask:\n      return height(realMask(layerRecord));\n    default:\n      return height(layerRecord) + 1;\n  }\n}\n\nfunction readLayerChannels(\n  cursor: Cursor,\n  channelInformation: [ChannelKind, number][],\n  layerRecord: LayerRecord,\n  fileVersionSpec: FileVersionSpec\n): LayerChannels {\n  const channels = new Map<ChannelKind, ChannelBytes>();\n\n  const {length} = channelInformation;\n  for (let i = 0; i < length; i++) {\n    const [channelKind, channelDataLength] = channelInformation[i];\n\n    // Each channel has its own compression method; a layer may contain multiple\n    // channels with different compression methods.\n    // This is different from the PSD Image Data section, which uses a single\n    // compression method for all channels.\n    const compression = matchChannelCompression(cursor.read(\"u16\"));\n    switch (compression) {\n      case ChannelCompression.RawData: {\n        const data = cursor.take(channelDataLength);\n        channels.set(channelKind, {compression, data});\n        break;\n      }\n      case ChannelCompression.RleCompressed: {\n        const data = cursor.take(\n          // Do not attempt to take more than the length of the channel data.\n          // This is needed because some layers (e.g. gradient fill layers) may\n          // have empty channel data (channelDataLength === 0).\n          channelDataLength > 0\n            ? rleCompressedSize(\n                cursor,\n                calcLayerHeight(layerRecord, channelKind),\n                fileVersionSpec.rleScanlineLengthFieldReadType\n              )\n            : channelDataLength\n        );\n        channels.set(channelKind, {compression, data});\n        break;\n      }\n    }\n  }\n\n  return channels;\n}\n\nfunction rleCompressedSize(\n  cursor: Cursor,\n  scanLines: number,\n  readType: ReadType\n): number {\n  const sizes = Array.from(Array(scanLines), () => cursor.read(readType));\n  return sizes.reduce((a, b) => a + b);\n}\n\nfunction readMaskData(cursor: Cursor): MaskData {\n  const length = cursor.read(\"u32\");\n  const startsAt = cursor.position;\n  const [top, left, bottom, right] = readBounds(cursor);\n  const backgroundColor = cursor.read(\"u8\");\n  const flags = readFlags(cursor);\n  const realData = length >= 36 ? readRealData(cursor) : undefined;\n  const parameters = flags.masksHaveParametersApplied\n    ? readParameters(cursor)\n    : undefined;\n\n  const remainingBytes = length - (cursor.position - startsAt);\n  cursor.pass(remainingBytes);\n\n  return {\n    top,\n    left,\n    bottom,\n    right,\n    backgroundColor,\n    flags,\n    parameters,\n    realData,\n  };\n}\n\nfunction readBounds(cursor: Cursor): [number, number, number, number] {\n  return Array.from(Array(4), () => cursor.read(\"i32\")) as [\n    number,\n    number,\n    number,\n    number\n  ];\n}\n\nenum MaskFlagsBitmask {\n  PositionRelativeToLayer = 1 << 0,\n  LayerMaskDisabled = 1 << 1,\n  InvertMaskWhenBlending = 1 << 2,\n  UserMaskFromRenderingOtherData = 1 << 3,\n  MasksHaveParametersApplied = 1 << 4,\n}\n\nfunction readFlags(cursor: Cursor): MaskFlags {\n  const flags = cursor.read(\"u8\");\n  return {\n    // bit 0 = position relative to layer\n    positionRelativeToLayer: Boolean(\n      flags & MaskFlagsBitmask.PositionRelativeToLayer\n    ),\n    // bit 1 = layer mask disabled\n    layerMaskDisabled: Boolean(flags & MaskFlagsBitmask.LayerMaskDisabled),\n    // bit 2 = invert layer mask when blending (Obsolete)\n    invertMaskWhenBlending: Boolean(\n      flags & MaskFlagsBitmask.InvertMaskWhenBlending\n    ),\n    // bit 3 = indicates that the user mask actually came from rendering other data\n    userMaskFromRenderingOtherData: Boolean(\n      flags & MaskFlagsBitmask.UserMaskFromRenderingOtherData\n    ),\n    // bit 4 = indicates that the user and/or vector masks have parameters applied to them\n    masksHaveParametersApplied: Boolean(\n      flags & MaskFlagsBitmask.MasksHaveParametersApplied\n    ),\n  };\n}\n\nenum MaskParameterBitmask {\n  // bit 0 = user mask density\n  UserMaskDensity = 1 << 0,\n  // bit 1 = user mask feather\n  UserMaskFeather = 1 << 1,\n  // bit 2 = vector mask density\n  VectorMaskDensity = 1 << 2,\n  // bit 3 = vector mask feather\n  VectorMaskFeather = 1 << 3,\n}\n\nfunction readParameters(cursor: Cursor): MaskParameters {\n  const parameters = cursor.read(\"u8\");\n  return {\n    // bit 0 = user mask density, 1 byte\n    userMaskDensity:\n      parameters & MaskParameterBitmask.UserMaskDensity\n        ? cursor.read(\"u8\")\n        : undefined,\n    // bit 1 = user mask feather, 8 byte, double\n    userMaskFeather:\n      parameters & MaskParameterBitmask.UserMaskFeather\n        ? cursor.read(\"f64\")\n        : undefined,\n    // bit 2 = vector mask density, 1 byte\n    vectorMaskDensity:\n      parameters & MaskParameterBitmask.VectorMaskDensity\n        ? cursor.read(\"u8\")\n        : undefined,\n    // bit 3 = vector mask feather, 8 bytes, double\n    vectorMaskFeather:\n      parameters & MaskParameterBitmask.VectorMaskFeather\n        ? cursor.read(\"f64\")\n        : undefined,\n  };\n}\n\nfunction readRealData(cursor: Cursor): RealMaskData {\n  const flags = readFlags(cursor);\n  const backgroundColor = cursor.read(\"u8\");\n  const [top, left, bottom, right] = readBounds(cursor);\n  return {top, left, bottom, right, flags, backgroundColor};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {FileVersionSpec, GroupDivider} from \"../../interfaces\";\nimport {Cursor, PanicFrameStackUnmatched} from \"../../utils\";\nimport {GroupFrame, LayerFrame} from \"./classes\";\nimport {AdditionalLayerProperties, Frame} from \"./interfaces\";\nimport {\n  readGlobalAdditionalLayerInformation,\n  readLayerRecordsAndChannels,\n} from \"./readLayerRecordsAndChannels\";\n\nexport * from \"./classes\";\nexport * from \"./interfaces\";\n\nexport type LayerAndMaskInformationSection = {\n  layers: LayerFrame[];\n  groups: GroupFrame[];\n  orders: (\"G\" | \"L\" | \"D\")[];\n  globalAdditionalLayerInformation: AdditionalLayerProperties;\n};\n\nexport function parseLayerAndMaskInformation(\n  dataView: DataView,\n  fileVersionSpec: FileVersionSpec\n): LayerAndMaskInformationSection {\n  const cursor = new Cursor(dataView);\n\n  // The first X bytes hold the length of the Layer and Mask Information section\n  cursor.pass(fileVersionSpec.layerAndMaskSectionLengthFieldSize);\n\n  // The Layer and Mask Information section consists of three segments:\n  // LayerInfo, GlobalLayerMaskInfo, and AdditionalLayerInfo.\n  // The next X bytes hold the length of the LayerInfo segment\n  cursor.pass(fileVersionSpec.layerInfoSectionLengthFieldSize);\n\n  /**\n   * If positive, this is the layer count.\n   * If negative, the absolute value is the layer count, and the first alpha\n   * channel contains the transparency information (i.e. opacity) of the result\n   * of merging all layers.\n   */\n  const layerCount = cursor.read(\"i16\");\n\n  /** Actual number of layers in the PSD file */\n  const absLayerCount = Math.abs(layerCount);\n\n  // Parse group (i.e. folder) count, layer information, and channel image data\n  const layerRecordsAndChannels = readLayerRecordsAndChannels(\n    cursor,\n    absLayerCount,\n    fileVersionSpec\n  );\n\n  cursor.padding(cursor.position, 4);\n\n  // Skip over Global layer mask info\n  // https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_17115\n  cursor.pass(cursor.read(\"u32\"));\n\n  const globalAdditionalLayerInformation = readGlobalAdditionalLayerInformation(\n    cursor,\n    fileVersionSpec\n  );\n\n  // Construct a list of layers and folders based on the parsed layer records.\n  // We defer construction of the layer grouping hierarchy (tree) to the\n  // constructor of the Psd class.\n\n  const layers: LayerFrame[] = [];\n  const groups: GroupFrame[] = [];\n  const orders: (\"G\" | \"L\" | \"D\")[] = [];\n\n  /** Root node (the PSD file itself) */\n  const root: Frame = {\n    startIndex: 0,\n    groupId: 0,\n    parentGroupId: 0,\n  };\n\n  /** Stack used to access the parent of each node */\n  const stack: Frame[] = [root];\n\n  /** Variable that is incremented to generate unique layer group IDs */\n  let alreadyViewed = 0;\n\n  for (let i = 0; i < absLayerCount; i++) {\n    const [layerRecord, channels] = layerRecordsAndChannels[i];\n    const currentGroupId = stack[stack.length - 1].groupId;\n\n    const {dividerType} = layerRecord;\n    if (\n      dividerType === GroupDivider.CloseFolder ||\n      dividerType === GroupDivider.OpenFolder\n    ) {\n      // Both CloseFolder and OpenFolder indicate the _start_ of a layer group.\n      // CloseFolder indicates the _beginning_ of a folder that is _visually_\n      // closed; it does NOT indicate the end of a folder.\n\n      alreadyViewed += 1;\n\n      stack.push({\n        startIndex: layers.length,\n        groupId: alreadyViewed,\n        parentGroupId: currentGroupId,\n        layerRecord,\n      });\n      orders.push(\"G\");\n    } else if (dividerType === GroupDivider.BoundingSection) {\n      // Indicates the end of a layer group\n\n      const frame: Frame | undefined = stack.pop();\n      if (frame === undefined) {\n        throw new PanicFrameStackUnmatched();\n      }\n\n      const groupId = frame.groupId > 0 ? frame.groupId : undefined;\n      const _layerRecord = frame.layerRecord || layerRecord;\n\n      groups.push(\n        GroupFrame.create(\n          _layerRecord.name,\n          frame.groupId,\n          _layerRecord,\n          groupId\n        )\n      );\n      orders.push(\"D\");\n    } else {\n      layers.push(LayerFrame.create(layerRecord, channels, currentGroupId));\n      orders.push(\"L\");\n    }\n  }\n\n  // Group must be sorted by ID\n  groups.sort((a, b) => a.id - b.id);\n\n  return {layers, groups, orders, globalAdditionalLayerInformation};\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nexport * from \"./ColorModeData\";\nexport * from \"./FileHeader\";\nexport * from \"./ImageData\";\nexport * from \"./ImageResource\";\nexport * from \"./LayerAndMaskInformation\";\n\nimport {getFileVersionSpec} from \"../interfaces\";\nimport {getUint64FromDataView} from \"../utils\";\nimport {FileHeaderSection, parseFileHeader} from \"./FileHeader\";\n\nconst FILE_HEADER_SECTION_LENGTH = 26;\n\n/**\n * Structure of a partially-parsed PSD file, generated by parsing only the file\n * header section.\n */\nexport type FileStructure = {\n  fileHeader: FileHeaderSection;\n  colorModeData: DataView;\n  imageResources: DataView;\n  layerAndMaskInformation: DataView;\n  imageData: DataView;\n};\n\nfunction parseSectionInfo(\n  dataView: DataView,\n  start: number,\n  lengthFieldSize: 4 | 8 = 4\n) {\n  const sectionLength =\n    lengthFieldSize === 4\n      ? dataView.getUint32(start)\n      : getUint64FromDataView(dataView, start);\n  const size = sectionLength + lengthFieldSize;\n\n  return {start, end: start + size, size};\n}\n\nexport function getFileStructure(buffer: ArrayBuffer): FileStructure {\n  const dataView = new DataView(buffer);\n\n  const fhStart = 0;\n  const fhSize = FILE_HEADER_SECTION_LENGTH;\n  // Parse the file header first, so that we can tell whether the file is a PSD\n  // or PSB and apply the appropriate parsing strategy (i.e. file version spec)\n  const fileHeaderView = new DataView(buffer, fhStart, fhSize);\n  const fileHeader = parseFileHeader(fileHeaderView);\n\n  const fileVersionSpec = getFileVersionSpec(fileHeader.version);\n\n  const cmd = parseSectionInfo(dataView, fhStart + fhSize);\n  const ir = parseSectionInfo(dataView, cmd.end);\n  const lmi = parseSectionInfo(\n    dataView,\n    ir.end,\n    fileVersionSpec.layerAndMaskSectionLengthFieldSize\n  );\n\n  return {\n    fileHeader,\n    colorModeData: new DataView(buffer, cmd.size),\n    imageResources: new DataView(buffer, ir.start, ir.size),\n    layerAndMaskInformation: new DataView(buffer, lmi.start, lmi.size),\n    imageData: new DataView(buffer, lmi.end),\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {PsdVersion} from \"../sections\";\nimport {InvalidVersion, ReadType} from \"../utils\";\n\n/**\n * Configuration object that describes structural differences (and therefore\n * differences in parsing strategy) between a PSD and PSB file.\n */\n// This interface is not a structural part of the PSD file format.\n// As such, it doesn't really belong in the `src/interfaces/` directory--placing\n// it here was a mistake.\n// TODO: Relocate this to a proper location.\nexport interface FileVersionSpec {\n  /**\n   * Maximum number of pixels in a single dimension.\n   * (i.e. upper limit of image width and height)\n   */\n  readonly maxPixels: number;\n  /**\n   * Size of each scanline length field in RLE-encoded image data.\n   */\n  readonly rleScanlineLengthFieldSize: 2 | 4;\n  /**\n   * Data type to use when reading a scanline length field in RLE-encoded image\n   * data.\n   */\n  readonly rleScanlineLengthFieldReadType: ReadType;\n  readonly layerAndMaskSectionLengthFieldSize: 4 | 8;\n  readonly layerInfoSectionLengthFieldSize: 4 | 8;\n  /**\n   * Data type to use when reading a channel length field in the Layer Record\n   * section.\n   */\n  readonly layerRecordSectionChannelLengthFieldReadType: ReadType;\n  /**\n   * Whether the Additional Layer Information block's length field size is fixed\n   * (4 bytes) or variable (4 or 8 bytes, depending on the key)\n   */\n  readonly aliLengthFieldSizeIsVariable: boolean;\n}\n\n/** Configuration object that describes how to parse a PSD (not PSB) file. */\nexport const PsdSpec: FileVersionSpec = {\n  maxPixels: 30_000,\n  rleScanlineLengthFieldSize: 2,\n  rleScanlineLengthFieldReadType: \"u16\",\n  layerAndMaskSectionLengthFieldSize: 4,\n  layerInfoSectionLengthFieldSize: 4,\n  layerRecordSectionChannelLengthFieldReadType: \"u32\",\n  aliLengthFieldSizeIsVariable: false,\n};\n\n/** Configuration object that describes how to parse a PSB file. */\nexport const PsbSpec: FileVersionSpec = {\n  maxPixels: 300_000,\n  rleScanlineLengthFieldSize: 4,\n  rleScanlineLengthFieldReadType: \"u32\",\n  layerAndMaskSectionLengthFieldSize: 8,\n  layerInfoSectionLengthFieldSize: 8,\n  layerRecordSectionChannelLengthFieldReadType: \"u64\",\n  aliLengthFieldSizeIsVariable: true,\n};\n\nexport function getFileVersionSpec(fileVersion: PsdVersion): FileVersionSpec {\n  switch (fileVersion) {\n    case PsdVersion.PSD:\n      return PsdSpec;\n    case PsdVersion.PSB:\n      return PsbSpec;\n    default:\n      throw new InvalidVersion();\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {InvalidCompression} from \"../utils\";\n\nexport enum ChannelCompression {\n  /** Uncompressed */\n  RawData,\n  /** Compressed with [PackBits RLE](https://en.wikipedia.org/wiki/PackBits) */\n  RleCompressed,\n  /** ZIP compression without prediction */\n  ZipWithoutPrediction,\n  /** ZIP compression with prediction */\n  ZipWithPrediction,\n}\n\nexport function matchChannelCompression(\n  compression: number\n): ChannelCompression {\n  if (!(compression in ChannelCompression)) {\n    throw new InvalidCompression();\n  }\n\n  return compression;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {UnsupportedChannelKindOffset} from \"../utils\";\n\nexport enum ChannelKind {\n  Red = 0,\n  Green = 1,\n  Blue = 2,\n  TransparencyMask = -1,\n  UserSuppliedLayerMask = -2,\n  RealUserSuppliedLayerMask = -3,\n}\n\nexport function getChannelKindOffset(channelKind: ChannelKind): 0 | 1 | 2 | 3 {\n  switch (channelKind) {\n    case ChannelKind.Red:\n      return 0;\n    case ChannelKind.Green:\n      return 1;\n    case ChannelKind.Blue:\n      return 2;\n    case ChannelKind.TransparencyMask:\n      return 3;\n    default:\n      throw new UnsupportedChannelKindOffset();\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {InvalidGroupDividerType} from \"../utils\";\n\n/**\n * Enumeration used to mark \"divider\" layers that group ordinary (non-divider)\n * layers into groups and subgroups.\n */\nexport enum GroupDivider {\n  /** 0: any other type of layer */\n  Other,\n  /** 1: open \"folder\" */\n  OpenFolder,\n  /** 2: closed \"folder\" */\n  CloseFolder,\n  /**  3: bounding section divider, hidden in the Photoshop UI */\n  BoundingSection,\n}\n\nexport function matchDividerType(divider: number): GroupDivider {\n  if (divider in GroupDivider) {\n    return divider as GroupDivider;\n  }\n\n  throw new InvalidGroupDividerType();\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {InvalidGuideDirection} from \"../../utils\";\nimport {ImageResourceBlockBase} from \"./ImageResourceBlockBase\";\nimport {ResourceType} from \"./ResourceType\";\n\nexport type GridAndGuidesResourceBlock = ImageResourceBlockBase<\n  ResourceType.GridAndGuides,\n  {\n    version: 1;\n    /** 문서별 그리드의 가로 간격 (실제로 쓰이지 않음) */\n    gridSizeX: number;\n    /** 문서별 그리드의 세로 간격 (실제로 쓰이지 않음) */\n    gridSizeY: number;\n    guides: Guide[];\n  }\n>;\n\n/**\n * Direction of a guide line.\n * @alpha\n */\nexport enum GuideDirection {\n  Vertical = 0,\n  Horizontal = 1,\n}\n\n/**\n * A single guide line in a PSD file.\n * @alpha\n */\nexport interface Guide {\n  /**\n   * Value in 32ths of a pixel. (example: 800px == 25600)\n   */\n  position: number;\n  direction: GuideDirection;\n}\n\nexport function matchGuideDirection(direction: number): GuideDirection {\n  if (!(direction in GuideDirection)) {\n    throw new InvalidGuideDirection();\n  }\n\n  return direction;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/** Image resource types known to @webtoon/psd */\nexport enum ResourceType {\n  GridAndGuides = 1032,\n  Slices = 1050,\n  ICCProfile = 1039,\n  GlobalLightAngle = 1037,\n  GlobalLightAltitude = 1049,\n  ResolutionInfo = 1005,\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {InvalidSliceOrigin} from \"../../utils\";\nimport {VersionedDescriptor} from \"../Descriptor\";\nimport {ImageResourceBlockBase} from \"./ImageResourceBlockBase\";\nimport {ResourceType} from \"./ResourceType\";\n\nexport type SlicesResourceBlock = ImageResourceBlockBase<\n  ResourceType.Slices,\n  SlicesResourceBlockV6 | SliceResourceBlockV7\n>;\n\n// Adobe Photoshop 6.0 and 7.0 use version === 6\n// Adobe Photoshop CS and later use version === 7 or 8\n// (Yes, this is confusing! Blame Adobe for this.)\n\ninterface SlicesResourceBlockV6 {\n  /** Version used by Photoshop 6.0-7.0 */\n  version: 6;\n  /** Top of bounding rectangle for all the slices */\n  boundTop: number;\n  /** Left of bounding rectangle for all the slices */\n  boundLeft: number;\n  /** Bottom of bounding rectangle for all the slices */\n  boundBottom: number;\n  /** Right of bounding rectangle for all the slices */\n  boundRight: number;\n  sliceGroupName: string;\n  slices: SliceEntry[];\n  /**\n   * Added in Photoshop 7.0\n   * May or may not exist, depending on the size of the slice resource block.\n   * This appears to store the duplicated contents of {@link slices}.\n   */\n  descriptor?: VersionedDescriptor;\n}\n\nexport interface SliceEntry {\n  id: number;\n  groupId: number;\n  origin: SliceOrigin;\n  /** Exists only if `origin` is 1 */\n  associatedLayerId?: number;\n  name: string;\n  type: number;\n  left: number;\n  top: number;\n  right: number;\n  bottom: number;\n  url: string;\n  target: string;\n  message: string;\n  altTag: string;\n  isCellTextHtml: boolean;\n  cellText: string;\n  horizontalAlignment: number;\n  verticalAlignment: number;\n  /** Alpha color */\n  alpha: number;\n  red: number;\n  green: number;\n  blue: number;\n}\n\n/**\n * Describes how a slice was created.\n * @alpha\n */\nexport enum SliceOrigin {\n  /**\n   * Slice is automatically generated by Photoshop, from the areas remaining\n   * after extracting the layer- and user-generated slices.\n   */\n  AutoGenerated = 0,\n  /**\n   * Slice is based on a layer's bounding box\n   */\n  LayerGenerated = 1,\n  /**\n   * Slice is created directly by the user\n   */\n  UserGenerated = 2,\n}\n\nexport function matchSliceOrigin(origin: number): SliceOrigin {\n  if (!(origin in SliceOrigin)) {\n    throw new InvalidSliceOrigin(`Invalid slice origin: ${origin}`);\n  }\n\n  return origin;\n}\n\ninterface SliceResourceBlockV7 {\n  version: 7 | 8;\n  descriptor: VersionedDescriptor;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ImageResourceBlockBase} from \"./ImageResourceBlockBase\";\nimport {ResourceType} from \"./ResourceType\";\n\nexport enum ResolutionUnit {\n  PixelsPerInch = 1,\n  PixelsPerCM = 2,\n}\n\nexport enum DimensionUnit {\n  Inch = 1,\n  CM = 2,\n  Point = 3, // 72 points == 1 inch\n  Pica = 4, // 6 pica == 1 inch\n  Column = 5,\n}\n\nexport interface ResolutionInfo {\n  horizontal: number;\n  horizontalUnit: ResolutionUnit;\n  widthUnit: DimensionUnit;\n  vertical: number;\n  verticalUnit: ResolutionUnit;\n  heightUnit: DimensionUnit;\n}\nexport type ResolutionInfoResourceBlock = ImageResourceBlockBase<\n  ResourceType.ResolutionInfo,\n  ResolutionInfo\n>;\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n/**\n * References are used to store dictionary-like data inside Descriptors.\n * (Descriptors can be nested, but References cannot.)\n * @see Descriptor\n */\nexport type Reference =\n  | ClassReference\n  | EnumeratedReference\n  | IdentifierReference\n  | IndexReference\n  | NameReference\n  | OffsetReference\n  | PropertyReference;\n\ninterface ReferenceBase<Type extends ReferenceType> {\n  type: Type;\n}\n\n/** Valid values for the `type` field in `Reference` objects. */\nexport enum ReferenceType {\n  Class = \"Clss\",\n  Enumerated = \"Enmr\",\n  Identifier = \"Idnt\",\n  Index = \"indx\",\n  Name = \"name\",\n  Offset = \"rele\",\n  Property = \"prop\",\n}\n\nexport interface ClassReference extends ReferenceBase<ReferenceType.Class> {\n  name: string;\n  classId: string;\n}\n\nexport interface EnumeratedReference\n  extends ReferenceBase<ReferenceType.Enumerated> {\n  name: string;\n  classId: string;\n  typeId: string;\n  enumValue: string;\n}\n\nexport interface IdentifierReference\n  extends ReferenceBase<ReferenceType.Identifier> {\n  identifier: string;\n}\n\nexport interface IndexReference extends ReferenceBase<ReferenceType.Index> {\n  index: number;\n}\n\nexport interface NameReference extends ReferenceBase<ReferenceType.Name> {\n  name: string;\n}\n\nexport interface OffsetReference extends ReferenceBase<ReferenceType.Offset> {\n  name: string;\n  classId: string;\n  /** 32-bit hexadecimal integer */\n  offset: number;\n}\n\nexport interface PropertyReference\n  extends ReferenceBase<ReferenceType.Property> {\n  name: string;\n  classId: string;\n  keyId: string;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ChannelKind, getChannelKindOffset} from \"../interfaces\";\nimport {InvalidOpacityValue} from \"../utils\";\n\nexport function applyOpacity(\n  pixels: Uint8ClampedArray,\n  opacity = 255\n): Uint8ClampedArray {\n  if (!(0 <= opacity && opacity <= 255)) {\n    throw new InvalidOpacityValue();\n  }\n\n  const length = pixels.length / 4;\n  const offset = getChannelKindOffset(ChannelKind.TransparencyMask);\n  const alpha = opacity / 255;\n\n  for (let i = 0; i < length; i++) {\n    const j = i * 4 + offset;\n\n    pixels[j] = Math.floor(alpha * pixels[j]);\n  }\n\n  return pixels;\n}\n","let m,e,Z,q,d,K,j,x,W,p,T,oA=(async()=>{const u=\"data:application/wasm;base64,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NwIMIAJBvIrAADYCCCACQQhqQZyEwAAQTwALQeyGwABBECACQfyGwABBnIvAABA2AAtBIEEIEH4ACxBNAAsACwNAEA4gAi0AEEUNAAsMAgsgAkEANgIIIAIgAkEIakHIisAAED0AC0Gsh8AAQStB2IrAABBIAAsgAigCCCIBRQ0AIAEgASgCACIBQX9qNgIAIAFBAUcNACACKAIIEEJBlJfAACgCACEBDAELQZSXwAAoAgAhAQwACwAL/QQBCn8jAEEwayIDJAAgA0EkaiABNgIAIANBAzoAKCADQoCAgICABDcDCCADIAA2AiAgA0EANgIYIANBADYCEAJ/AkACQCACKAIIIgpFBEAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQUgAEF/akH/////AXFBAWohByACKAIAIQADQCAAQQRqKAIAIgQEQCADKAIgIAAoAgAgBCADKAIkKAIMEQIADQQLIAEoAgAgA0EIaiABQQRqKAIAEQAADQMgAUEIaiEBIABBCGohACAFQXhqIgUNAAsMAQsgAkEMaigCACIARQ0AIABBBXQhCyAAQX9qQf///z9xQQFqIQcgAigCACEAA0AgAEEEaigCACIBBEAgAygCICAAKAIAIAEgAygCJCgCDBECAA0DCyADIAUgCmoiBEEcai0AADoAKCADIARBBGopAgBCIIk3AwggBEEYaigCACEGIAIoAhAhCEEAIQlBACEBAkACQAJAIARBFGooAgBBAWsOAgACAQsgBkEDdCAIaiIMQQRqKAIAQSRHDQEgDCgCACgCACEGC0EBIQELIAMgBjYCFCADIAE2AhAgBEEQaigCACEBAkACQAJAIARBDGooAgBBAWsOAgACAQsgAUEDdCAIaiIGQQRqKAIAQSRHDQEgBigCACgCACEBC0EBIQkLIAMgATYCHCADIAk2AhggCCAEKAIAQQN0aiIBKAIAIANBCGogASgCBBEAAA0CIABBCGohACALIAVBIGoiBUcNAAsLIAcgAigCBEkEQCADKAIgIAIoAgAgB0EDdGoiACgCACAAKAIEIAMoAiQoAgwRAgANAQtBAAwBC0EBCyADQTBqJAALzQQBBH8gACABEIIBIQICQAJAAkAgABB7DQAgACgCACEDAkAgABBwRQRAIAEgA2ohASAAIAMQgwEiAEHwmsAAKAIARw0BIAIoAgRB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QAJAAkAgBA4CAgEACxB4AAtBASEGCyAFQQhqIAEgAiADIAYQGCAFKAIMIQEgBSgCCCEEIAMEQCACEAYLIAAgBDYCACAAIAE2AgQgBUEQaiQAC1YBAn8jAEEgayICJAAgAUEcaigCACEDIAEoAhggAkEYaiAAQRBqKQIANwMAIAJBEGogAEEIaikCADcDACACIAApAgA3AwggAyACQQhqEAwgAkEgaiQAC2wBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakERNgIAIANCAjcCDCADQfiWwAA2AgggA0ERNgIkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhBPAAtmAQF/IwBBIGsiAiQAIAJBxI7AADYCBCACIAA2AgAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkGMh8AAIAJBBGpBjIfAACACQQhqQaiPwAAQFAALYwEBfyMAQSBrIgMkACADQcSKwAA2AgQgAyAANgIAIANBGGogAUEQaikCADcDACADQRBqIAFBCGopAgA3AwAgAyABKQIANwMIIANBnIfAACADQQRqQZyHwAAgA0EIaiACEBQAC1kBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBkIbAACACQQhqEAwgAkEgaiQAC1kBAX8jAEEgayICJAAgAiAAKAIANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpB1IbAACACQQhqEAwgAkEgaiQAC2cAIwBBMGsiASQAQZCXwAAtAAAEQCABQRxqQQE2AgAgAUICNwIMIAFB0IvAADYCCCABQRE2AiQgASAANgIsIAEgAUEgajYCGCABIAFBLGo2AiAgAUEIakH4i8AAEE8ACyABQTBqJAALVgEBfyMAQSBrIgIkACACIAA2AgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakGQhsAAIAJBCGoQDCACQSBqJAALUQEBfwJAIABBEGooAgAiAUUNACABQQA6AAAgAEEUaigCAEUNACAAKAIQEAYLAkAgAEF/Rg0AIAAgACgCBCIBQX9qNgIEIAFBAUcNACAAEAYLC1wBA38jAEEQayIBJAACQCAAKAIMIgIEQCAAKAIIIgNFDQEgASACNgIIIAEgADYCBCABIAM2AgAgARBWAAtBrIfAAEErQYCNwAAQSAALQayHwABBK0HwjMAAEEgAC0oBAX8gACgCACIAQQRqKAIAIAAoAggiA2sgAkkEQCAAIAMgAhAnIAAoAgghAwsgACgCACADaiABIAIQgAEaIAAgAiADajYCCEEAC0cBAX8gACgCACIAKAIEIAAoAggiA2sgAkkEQCAAIAMgAhAmIAAoAgghAwsgACgCACADaiABIAIQgAEaIAAgAiADajYCCEEACzoBAX8jAEEQayIAJABBlJfAACgCAEEDRwRAIABBAToACyAAIABBC2o2AgwgAEEMahALCyAAQRBqJAALQgEBfyAAKAIEIAAoAggiA2sgAkkEQCAAIAMgAhAmIAAoAgghAwsgACgCACADaiABIAIQgAEaIAAgAiADajYCCEEAC0cBAX8jAEEgayIDJAAgA0EUakEANgIAIANBgJLAADYCECADQgE3AgQgAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEE8AC0cBAX8jAEEgayICJAAgAkEUakEBNgIAIAJCATcCBCACQciSwAA2AgAgAkEnNgIcIAIgADYCGCACIAJBGGo2AhAgAiABEE8AC0QBAn8gASgCBCECIAEoAgAhA0EIQQQQayIBRQRAQQhBBBB+AAsgASACNgIEIAEgAzYCACAAQaCNwAA2AgQgACABNgIACzkBAX8gAUEQdkAAIQIgAEEANgIIIABBACABQYCAfHEgAkF/RiIBGzYCBCAAQQAgAkEQdCABGzYCAAs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAAANARoLIAMNAUEACw8LIAAgAyAEIAEoAgwRAgALPwEBfyMAQSBrIgAkACAAQRxqQQA2AgAgAEHshsAANgIYIABCATcCDCAAQZyJwAA2AgggAEEIakGkicAAEE8ACz8BAX8jAEEgayIAJAAgAEEcakEANgIAIABBuJHAADYCGCAAQgE3AgwgAEHokcAANgIIIABBCGpB8JHAABBPAAs+AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJB0JLAADYCDCACQYCSwAA2AgggAkEIahBDAAsyAAJAIABB/P///wdLDQAgAEUEQEEEDwsgACAAQf3///8HSUECdBBrIgBFDQAgAA8LAAs9AQF/IAAoAgAhAQJAIABBBGotAAANAEHIl8AAKAIAQf////8HcUUNABCBAQ0AIAFBAToAAQsgAUEAOgAACzsAIAAoAgAhACABLQAAQRBxQQR2RQRAIAEtAABBIHFBBXZFBEAgACABEHUPCyAAIAEQNA8LIAAgARAzCyIAIwBBEGsiACQAIABBCGogARBYIABBCGoQMCAAQRBqJAALJgEBfwJAIABBARASIgFFDQAgARCFARBwDQAgAUEAIAAQfxoLIAELKwAgACgCACIALQAAIABBADoAAEEBcUUEQEGsgMAAQStBpIHAABBIAAsQLgssAQF/IwBBEGsiASQAIAFBCGogAEEIaigCADYCACABIAApAgA3AwAgARA1AAs3ACAAQQM6ACAgAEKAgICAgAQ3AgAgACABNgIYIABBADYCECAAQQA2AgggAEEcakHIhMAANgIACzUBAX8gASgCGEHoisAAQQsgAUEcaigCACgCDBECACECIABBADoABSAAIAI6AAQgACABNgIACycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsgAQF/AkAgACgCBCIBRQ0AIABBCGooAgBFDQAgARAGCwslAQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIaiACEEkACyIAAkAgAUH8////B00EQCAAIAFBBCACEGYiAA0BCwALIAALIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALHgAgACABQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIECxQAIABBBGooAgAEQCAAKAIAEAYLCxkBAX8gACgCECIBBH8gAQUgAEEUaigCAAsLEgBBAEEZIABBAXZrIABBH0YbCxYAIAAgAUEBcjYCBCAAIAFqIAE2AgALHAAgASgCGEGAksAAQQ4gAUEcaigCACgCDBECAAscACABKAIYQYiXwABBBSABQRxqKAIAKAIMEQIACxAAIAAgAWpBf2pBACABa3ELDAAgACABIAIgAxAJCwsAIAEEQCAAEAYLCw8AIABBAXQiAEEAIABrcgsVACABIAAoAgAiACgCACAAKAIEEAcLFAAgACgCACABIAAoAgQoAgwRAAALCAAgACABEBILEwAgAEGgjcAANgIEIAAgATYCAAsNACAALQAEQQJxQQF2CxAAIAEgACgCACAAKAIEEAcLCgBBACAAayAAcQsLACAALQAEQQNxRQsMACAAIAFBA3I2AgQLDQAgACgCACAAKAIEagsOACAAKAIAGgNADAALAAsLACAAIAEgAhA7AAsLACAANQIAIAEQHAsLACAAIAEgAhBbAAsLACAAIwBqJAAjAAsMAEGshMAAQRkQBAALKQACfyAAKAIALQAARQRAIAFBjpbAAEEFEAcMAQsgAUGKlsAAQQQQBwsLCgAgACgCBEF4cQsKACAAKAIEQQFxCwoAIAAoAgxBAXELCgAgACgCDEEBdgsZACAAIAFBuJfAACgCACIAQRIgABsRAQAACwoAIAAgASACEC0LCgAgACABIAIQGwsLAEGkm8AAKAIARQsHACAAIAFqCwcAIAAgAWsLBwAgAEEIagsHACAAQXhqCwYAIAEQEwsMAELIhfmknrfU2xILDQBC65GTtfbYs6L0AAsMAEK4ic+XicbR+EwLAwABCwuXFwEAQYCAwAALjRcBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAABAAAABAAAAAQAAAAFAAAABgAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvcnVzdGMvODk3ZTM3NTUzYmJhOGI0Mjc1MWM2NzY1ODk2Nzg4OWQxMWVjZDEyMC9saWJyYXJ5L3N0ZC9zcmMvc3luYy9vbmNlLnJzAFcAEABMAAAAFAEAACkAAABvdXRwdXQgc2xpY2UgaXMgdG9vIHNtYWxsc3JjL2xpYi5ycwDNABAACgAAAIYAAAAbAAAAaW5wdXQgdGVybWluYXRlZCB3aGlsZSBkZWNvZGluZyB1bmNvbXByZXNzZWQgc2VnbWVudCBpbiBSTEUgc2xpY2UAAADNABAACgAAAJ0AAAAjAAAAzQAQAAoAAACaAAAAIwAAAGlucHV0IHRlcm1pbmF0ZWQgd2hpbGUgZGVjb2RpbmcgcmVwZWF0IHNlZ21lbnQgaW4gUkxFIHNsaWNlAM0AEAAKAAAAqgAAACMAAADNABAACgAAAKUAAAAbAAAAL1VzZXJzL21hY2llai5ub3dha293c2tpLy5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2NvbnNvbGVfZXJyb3JfcGFuaWNfaG9vay0wLjEuNy9zcmMvbGliLnJzAACoARAAcgAAAJUAAAAOAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZAAAAAcAAAAMAAAABAAAAAgAAAAJAAAACgAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkACwAAAAAAAAABAAAADAAAAC9ydXN0Yy84OTdlMzc1NTNiYmE4YjQyNzUxYzY3NjU4OTY3ODg5ZDExZWNkMTIwL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCoAhAASwAAAM4JAAAJAAAACgpTdGFjazoKCgAADQAAAAQAAAAEAAAADgAAAA8AAAAQAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQATAAAABAAAAAQAAAAUAAAAFQAAABYAAABhbHJlYWR5IGJvcnJvd2VkEwAAAAAAAAABAAAAFwAAABMAAAAEAAAABAAAABgAAAATAAAABAAAAAQAAAAZAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZXVzZSBvZiBzdGQ6OnRocmVhZDo6Y3VycmVudCgpIGlzIG5vdCBwb3NzaWJsZSBhZnRlciB0aGUgdGhyZWFkJ3MgbG9jYWwgZGF0YSBoYXMgYmVlbiBkZXN0cm95ZWRsaWJyYXJ5L3N0ZC9zcmMvdGhyZWFkL21vZC5ycwAANQQQAB0AAACyAgAABQAAAGZhaWxlZCB0byBnZW5lcmF0ZSB1bmlxdWUgdGhyZWFkIElEOiBiaXRzcGFjZSBleGhhdXN0ZWQAZAQQADcAAAA1BBAAHQAAABcEAAANAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvb25jZS5yc2Fzc2VydGlvbiBmYWlsZWQ6IHN0YXRlX2FuZF9xdWV1ZS5hZGRyKCkgJiBTVEFURV9NQVNLID09IFJVTk5JTkdPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAABAFEAAqAAAAAgAAALQEEAAcAAAA/wEAAAkAAAC0BBAAHAAAAAwCAAAeAAAAUG9pc29uRXJyb3JsaWJyYXJ5L3N0ZC9zcmMvc3lzX2NvbW1vbi90aHJlYWRfaW5mby5yc3MFEAApAAAAFgAAADMAAABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkCgCsBRAAFQAAAMEFEAAOAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJz4AUQABgAAABVAQAACQAAAGNhbm5vdCBtb2RpZnkgdGhlIHBhbmljIGhvb2sgZnJvbSBhIHBhbmlja2luZyB0aHJlYWQIBhAANAAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnNEBhAAHAAAAH0AAAAJAAAARAYQABwAAABHAgAADwAAAEQGEAAcAAAARgIAAA8AAAAaAAAADAAAAAQAAAAbAAAAEwAAAAgAAAAEAAAAHAAAAB0AAAAQAAAABAAAAB4AAAAfAAAAEwAAAAgAAAAEAAAAIAAAACEAAABjb25kdmFyIHdhaXQgbm90IHN1cHBvcnRlZAAA2AYQABoAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvbG9ja3MvY29uZHZhci5yc/wGEAA4AAAAFQAAAAkAAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAAABFBxAAIAAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAAcAcQADYAAAAVAAAACQAAACIAAAAIAAAABAAAACMAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzX2NvbW1vbi90aHJlYWRfcGFya2VyL2dlbmVyaWMucnMAyAcQADMAAAAnAAAAFQAAAGluY29uc2lzdGVudCBwYXJrIHN0YXRlAAwIEAAXAAAAyAcQADMAAAA1AAAAFwAAAHBhcmsgc3RhdGUgY2hhbmdlZCB1bmV4cGVjdGVkbHkAPAgQAB8AAADIBxAAMwAAADIAAAARAAAAaW5jb25zaXN0ZW50IHN0YXRlIGluIHVucGFya3QIEAAcAAAAyAcQADMAAABsAAAAEgAAAMgHEAAzAAAAegAAAA4AAABsaWJyYXJ5L2FsbG9jL3NyYy9yYXdfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAADUCBAAEQAAALgIEAAcAAAABgIAAAUAAABCb3Jyb3dNdXRFcnJvcjoAAAkQAAAAAAAOCRAAAQAAAA4JEAABAAAAcGFuaWNrZWQgYXQgJycsIDQJEAABAAAANQkQAAMAAAAACRAAAAAAACoAAAAAAAAAAQAAACsAAABtYXRjaGVzIT09PWFzc2VydGlvbiBmYWlsZWQ6IGAobGVmdCAgcmlnaHQpYAogIGxlZnQ6IGBgLAogcmlnaHQ6IGBgOiAAAABrCRAAGQAAAIQJEAASAAAAlgkQAAwAAACiCRAAAwAAAGAAAABrCRAAGQAAAIQJEAASAAAAlgkQAAwAAADICRAAAQAAADogAAAACRAAAAAAAOwJEAACAAAAICAgIC4uCn0sIC4uIH0geyAuLiB9bGlicmFyeS9jb3JlL3NyYy9mbXQvbnVtLnJzFQoQABsAAABlAAAAFAAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTl0cnVlZmFsc2VsaWJyYXJ5L2NvcmUvc3JjL3NsaWNlL21lbWNoci5ycwATCxAAIAAAAGgAAAAnAAAAcmFuZ2Ugc3RhcnQgaW5kZXggIG91dCBvZiByYW5nZSBmb3Igc2xpY2Ugb2YgbGVuZ3RoIEQLEAASAAAAVgsQACIAAABFcnJvcgB7CXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS42NS4wICg4OTdlMzc1NTMgMjAyMi0xMS0wMikGd2FscnVzBjAuMTkuMAx3YXNtLWJpbmRnZW4SMC4yLjgwICg0Y2FhOTgxNjUp\",V=async(A={},B)=>{let I;if(B.startsWith(\"data:\")){const C=B.replace(/^data:.*?base64,/,\"\");let Q;if(typeof Buffer==\"function\"&&typeof Buffer.from==\"function\")Q=Buffer.from(C,\"base64\");else if(typeof atob==\"function\"){const i=atob(C);Q=new Uint8Array(i.length);for(let g=0;g<i.length;g++)Q[g]=i.charCodeAt(g)}else throw new Error(\"Cannot decode base64-encoded data URL\");I=await WebAssembly.instantiate(Q,A)}else{const C=await fetch(B),Q=C.headers.get(\"Content-Type\")||\"\";if(\"instantiateStreaming\"in WebAssembly&&Q.startsWith(\"application/wasm\"))I=await WebAssembly.instantiateStreaming(C,A);else{const i=await C.arrayBuffer();I=await WebAssembly.instantiate(i,A)}}return I.instance.exports},Y=new Array(32).fill(void 0);Y.push(void 0,null,!0,!1);function r(A){return Y[A]}let R=Y.length;function v(A){A<36||(Y[A]=R,R=A)}function z(A){const B=r(A);return v(A),B}const O=typeof TextDecoder>\"u\"?(0,module.require)(\"util\").TextDecoder:TextDecoder;let b=new O(\"utf-8\",{ignoreBOM:!0,fatal:!0});b.decode();let U=null;function s(){return(U===null||U.buffer!==n.buffer)&&(U=new Uint8Array(n.buffer)),U}function X(A,B){return b.decode(s().subarray(A,A+B))}T=function(){BA()};let D=0;function o(A,B){const I=B(A.length*1);return s().set(A,I/1),D=A.length,I}let S=null;function J(){return(S===null||S.buffer!==n.buffer)&&(S=new Int32Array(n.buffer)),S}function H(A,B){return s().subarray(A/1,A/1+B)}W=function(B,I,C,Q,i,g,E){try{const F=a(-16),k=o(I,N),M=D,f=o(Q,N),t=D,l=o(g,N);IA(F,B,k,M,C,f,t,i,l,D,E);var w=J()[F/4+0],c=J()[F/4+1],y=H(w,c).slice();return h(w,c*1),y}finally{a(16)}},p=function(B,I,C,Q,i,g,E,w,c){try{const M=a(-16),f=o(I,N),t=D,l=o(Q,N),DA=D,wA=o(g,N),GA=D,NA=o(w,N);gA(M,B,f,t,C,l,DA,i,wA,GA,E,NA,D,c);var y=J()[M/4+0],F=J()[M/4+1],k=H(y,F).slice();return h(y,F*1),k}finally{a(16)}},j=function(B,I,C){try{const E=a(-16),w=o(I,N);QA(E,B,w,D,C);var Q=J()[E/4+0],i=J()[E/4+1],g=H(Q,i).slice();return h(Q,i*1),g}finally{a(16)}},x=function(B,I,C,Q,i){try{const c=a(-16),y=o(I,N),F=D,k=o(Q,N);CA(c,B,y,F,C,k,D,i);var g=J()[c/4+0],E=J()[c/4+1],w=H(g,E).slice();return h(g,E*1),w}finally{a(16)}};function _(A){R===Y.length&&Y.push(Y.length+1);const B=R;return R=Y[B],Y[B]=A,B}const P=typeof TextEncoder>\"u\"?(0,module.require)(\"util\").TextEncoder:TextEncoder;let L=new P(\"utf-8\");const $=typeof L.encodeInto==\"function\"?function(A,B){return L.encodeInto(A,B)}:function(A,B){const I=L.encode(A);return B.set(I),{read:A.length,written:I.length}};function AA(A,B,I){if(I===void 0){const E=L.encode(A),w=B(E.length);return s().subarray(w,w+E.length).set(E),D=E.length,w}let C=A.length,Q=B(C);const i=s();let g=0;for(;g<C;g++){const E=A.charCodeAt(g);if(E>127)break;i[Q+g]=E}if(g!==C){g!==0&&(A=A.slice(g)),Q=I(Q,C,C=g+A.length*3);const E=s().subarray(Q+g,Q+C);g+=$(A,E).written}return D=g,Q}m=Object.freeze({Raw:0,0:\"Raw\",RleCompressed:1,1:\"RleCompressed\"}),Z=function(){const B=new Error;return _(B)},q=function(B,I){const C=r(I).stack,Q=AA(C,N,EA),i=D;J()[B/4+1]=i,J()[B/4+0]=Q},e=function(B,I){try{console.error(X(B,I))}finally{h(B,I)}},d=function(B){z(B)},K=function(B,I){throw new Error(X(B,I))};const G=await V({\"./webtoon_psd_decoder_bg.js\":{__wbg_new_693216e109162396:Z,__wbg_stack_0ddaca5d1abfb52f:q,__wbg_error_09919627ac0992f5:e,__wbindgen_object_drop_ref:d,__wbindgen_throw:K}},u),n=G.memory,BA=G.main_js,IA=G.decode_rgb,gA=G.decode_rgba,QA=G.decode_grayscale,CA=G.decode_grayscale_a,a=G.__wbindgen_add_to_stack_pointer,N=G.__wbindgen_malloc,h=G.__wbindgen_free,EA=G.__wbindgen_realloc,iA=G.__wbindgen_start;iA()})();export{m as ChannelCompression,e as __wbg_error_09919627ac0992f5,Z as __wbg_new_693216e109162396,q as __wbg_stack_0ddaca5d1abfb52f,d as __wbindgen_object_drop_ref,K as __wbindgen_throw,j as decode_grayscale,x as decode_grayscale_a,W as decode_rgb,p as decode_rgba,oA as init,T as main_js};\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport * as wasmDecoder from \"@webtoon/psd-decoder\";\nimport {ChannelBytes, ChannelCompression} from \"../interfaces\";\nimport {UnsupportedCompression} from \"../utils\";\n\n/**\n * Decodes one or more encoded channels and combines them into an image.\n * @param width Width of the decoded image in pixels\n * @param height Height of the decoded image in pixels\n * @param red Encoded red channel data\n * @param green Encoded green channel data\n * @param blue Encoded blue channel data\n * @param alpha Encoded alpha channel data\n * @returns `Uint8ClampedArray` containing the pixel data of the decoded image.\n *    Each pixel takes up 4 bytes--1 byte for red, blue, green, and alpha.\n */\nexport async function generateRgba(\n  width: number,\n  height: number,\n  red: ChannelBytes,\n  green?: ChannelBytes,\n  blue?: ChannelBytes,\n  alpha?: ChannelBytes\n): Promise<Uint8ClampedArray> {\n  const pixelCount = width * height;\n\n  if (!(pixelCount > 0 && Number.isInteger(pixelCount))) {\n    throw new Error(\n      `Pixel count must be a positive integer, got ${pixelCount}`\n    );\n  }\n\n  let result: Uint8Array;\n  if (green && blue) {\n    result = await decodeRgb(pixelCount, red, green, blue, alpha);\n  } else if (!blue && !green) {\n    result = await decodeGrayscale(pixelCount, red, alpha);\n  } else {\n    throw new Error(`Missing ${blue ? \"green\" : \"blue\"} channel in RGB image`);\n  }\n\n  return new Uint8ClampedArray(\n    result.buffer,\n    result.byteOffset,\n    result.byteLength\n  );\n}\n\nfunction validateSupportedCompression(\n  compression: ChannelCompression\n): asserts compression is\n  | ChannelCompression.RawData\n  | ChannelCompression.RleCompressed {\n  switch (compression) {\n    case ChannelCompression.RawData:\n    case ChannelCompression.RleCompressed:\n      return;\n  }\n  throw new UnsupportedCompression(\n    `Unsupported compression method: ${compression}`\n  );\n}\n\nexport async function decodeRgb(\n  pixels: number,\n  red: ChannelBytes,\n  green: ChannelBytes,\n  blue: ChannelBytes,\n  alpha?: ChannelBytes\n) {\n  await wasmDecoder.init;\n\n  validateSupportedCompression(red.compression);\n  validateSupportedCompression(blue.compression);\n  validateSupportedCompression(red.compression);\n  if (alpha) {\n    validateSupportedCompression(alpha.compression);\n  }\n\n  return alpha\n    ? wasmDecoder.decode_rgba(\n        pixels,\n        red.data,\n        red.compression,\n        green.data,\n        green.compression,\n        blue.data,\n        blue.compression,\n        alpha.data,\n        alpha.compression\n      )\n    : wasmDecoder.decode_rgb(\n        pixels,\n        red.data,\n        red.compression,\n        green.data,\n        green.compression,\n        blue.data,\n        blue.compression\n      );\n}\n\nexport async function decodeGrayscale(\n  pixels: number,\n  color: ChannelBytes,\n  alpha?: ChannelBytes\n) {\n  await wasmDecoder.init;\n\n  validateSupportedCompression(color.compression);\n  if (alpha) {\n    validateSupportedCompression(alpha.compression);\n  }\n\n  return alpha\n    ? wasmDecoder.decode_grayscale_a(\n        pixels,\n        color.data,\n        color.compression,\n        alpha.data,\n        alpha.compression\n      )\n    : wasmDecoder.decode_grayscale(pixels, color.data, color.compression);\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {getFileVersionSpec, ParsingResult} from \"../interfaces\";\nimport {\n  getFileStructure,\n  parseImageData,\n  parseImageResource,\n  parseLayerAndMaskInformation,\n} from \"../sections\";\n\n/** @internal */\nexport function parse(buffer: ArrayBuffer): ParsingResult {\n  const fileStructure = getFileStructure(buffer);\n\n  const {fileHeader} = fileStructure;\n  const fileVersionSpec = getFileVersionSpec(fileHeader.version);\n\n  const imageResources = parseImageResource(fileStructure.imageResources);\n  const layerAndMaskInfo = parseLayerAndMaskInformation(\n    fileStructure.layerAndMaskInformation,\n    fileVersionSpec\n  );\n  const imageData = parseImageData(\n    fileStructure.imageData,\n    fileHeader.depth,\n    fileHeader.height,\n    fileHeader.channelCount,\n    fileVersionSpec\n  );\n\n  return {\n    fileHeader,\n    colorModeData: undefined,\n    imageResources,\n    layerAndMaskInfo,\n    imageData,\n  };\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  Descriptor,\n  DescriptorValue,\n  DescriptorValueType,\n  Reference,\n  ReferenceType,\n  UnitFloatType,\n  VersionedDescriptor,\n} from \"../interfaces\";\nimport {\n  Cursor,\n  DuplicateDescriptorKey,\n  InvalidDescriptorType,\n  InvalidDescriptorVersion,\n  InvalidReferenceType,\n  InvalidUnitFloatType,\n} from \"../utils\";\n\n/**\n * Reads a {@link Descriptor} from the current {@link cursor} position.\n * @param cursor\n */\nexport function readDescriptor(cursor: Cursor): Descriptor {\n  const name = cursor.readUnicodeString(0);\n  const classId = cursor.readIdString();\n  const itemCount = cursor.read(\"u32\");\n\n  const items = new Map<string, DescriptorValue>();\n  while (items.size < itemCount) {\n    const key = cursor.readIdString();\n    const value = readDescriptorValue(cursor);\n    if (items.has(key)) {\n      // If this ever happens, it means that descriptors can store duplicate\n      // keys, and therefore cannot be represented safely as Maps.\n      // Since other PSD parsers (psd.js, psd-tools, psd.rb) are already using\n      // dictionary-like structures to store descriptors, we follow suit.\n      throw new DuplicateDescriptorKey(`Duplicate descriptor key: ${key}`);\n    }\n    items.set(key, value);\n  }\n\n  return {name, classId, items};\n}\n\n/**\n * Reads a {@link VersionedDescriptor} from the current {@link cursor} position.\n */\nexport function readVersionedDescriptor(cursor: Cursor): VersionedDescriptor {\n  const descriptorVersion = cursor.read(\"u32\");\n  if (descriptorVersion !== 16) {\n    throw new InvalidDescriptorVersion(\n      `Invalid descriptor version: ${descriptorVersion}`\n    );\n  }\n\n  const descriptor = readDescriptor(cursor);\n\n  return {descriptorVersion, descriptor};\n}\n\n/**\n * Reads a {@link DescriptorValue} from the current {@link cursor} position.\n * @param cursor\n */\nfunction readDescriptorValue(cursor: Cursor): DescriptorValue {\n  const type = cursor.readString(4) as DescriptorValueType;\n\n  switch (type) {\n    case DescriptorValueType.Alias: {\n      const length = cursor.read(\"u32\");\n      const data = cursor.take(length);\n      return {type, data};\n    }\n    case DescriptorValueType.Boolean: {\n      const value = Boolean(cursor.read(\"u8\"));\n      return {type, value};\n    }\n    case DescriptorValueType.Class:\n    case DescriptorValueType.GlobalClass: {\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      return {type, name, classId};\n    }\n    case DescriptorValueType.Descriptor:\n    case DescriptorValueType.GlobalObject: {\n      const descriptor = readDescriptor(cursor);\n      return {type, descriptor};\n    }\n    case DescriptorValueType.Double: {\n      const value = cursor.read(\"f64\");\n      return {type, value};\n    }\n    case DescriptorValueType.Enumerated: {\n      const enumType = cursor.readIdString();\n      const enumValue = cursor.readIdString();\n      return {type, enumType, enumValue};\n    }\n    case DescriptorValueType.Integer: {\n      const value = cursor.read(\"i32\");\n      return {type, value};\n    }\n    case DescriptorValueType.LargeInteger: {\n      const value = cursor.read(\"i64\");\n      return {type, value};\n    }\n    case DescriptorValueType.List: {\n      const valueCount = cursor.read(\"u32\");\n\n      const values: DescriptorValue[] = [];\n      while (values.length < valueCount) {\n        values.push(readDescriptorValue(cursor));\n      }\n\n      return {type, values};\n    }\n    case DescriptorValueType.RawData: {\n      // The Adobe spec document is unclear on how this section is structured;\n      // We assume it's similar to text engine data\n      const size = cursor.read(\"u32\");\n      const data = cursor.take(size);\n      return {type, data};\n    }\n    case DescriptorValueType.Reference: {\n      const itemCount = cursor.read(\"u32\");\n\n      const references: Reference[] = [];\n      while (references.length < itemCount) {\n        references.push(readReference(cursor));\n      }\n\n      return {type, references};\n    }\n    case DescriptorValueType.String: {\n      const value = cursor.readUnicodeString(0);\n      return {type, value};\n    }\n    case DescriptorValueType.UnitFloat: {\n      const unitType = matchUnitFloatType(cursor.readString(4));\n      const value = cursor.read(\"f64\");\n      return {type, unitType, value};\n    }\n    case DescriptorValueType.ObjectArray: {\n      // const itemsPerObjectCount\n      cursor.read(\"u32\");\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      const itemsCount = cursor.read(\"u32\");\n      const items = Array.from(Array(itemsCount), () => {\n        const key = cursor.readIdString();\n        const value = readDescriptorValue(cursor);\n        return {key, value};\n      });\n      return {type, classObj: {name, classId}, items};\n    }\n    case DescriptorValueType.UnitFloats: {\n      const unitType = matchUnitFloatType(cursor.readString(4));\n      const valuesCount = cursor.read(\"u32\");\n      const values = Array.from(Array(valuesCount), () => cursor.read(\"f64\"));\n      return {type, unitType, values};\n    }\n    default:\n      throw new InvalidDescriptorType(`Unexpected descriptor type: ${type}`);\n  }\n}\n\n/**\n * Reads a {@link Reference} from the current {@link cursor} position.\n * @param cursor\n */\nfunction readReference(cursor: Cursor): Reference {\n  const type = cursor.readString(4) as ReferenceType;\n\n  switch (type) {\n    case ReferenceType.Class: {\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      return {type, name, classId};\n    }\n    case ReferenceType.Enumerated: {\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      const typeId = cursor.readIdString();\n      const enumValue = cursor.readIdString();\n      return {type, name, classId, typeId, enumValue};\n    }\n    case ReferenceType.Identifier: {\n      // This is undocumented in Adobe's PSD file format docs\n      const identifier = cursor.readString(4);\n      return {type, identifier};\n    }\n    case ReferenceType.Index: {\n      // This is undocumented in Adobe's PSD file format docs\n      const index = cursor.read(\"u32\");\n      return {type, index};\n    }\n    case ReferenceType.Name: {\n      // This is undocumented in Adobe's PSD file format docs\n      const name = cursor.readUnicodeString(0);\n      return {type, name};\n    }\n    case ReferenceType.Offset: {\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      const offset = cursor.read(\"u32\");\n      return {type, name, classId, offset};\n    }\n    case ReferenceType.Property: {\n      const name = cursor.readUnicodeString(0);\n      const classId = cursor.readIdString();\n      const keyId = cursor.readIdString();\n      return {type, name, classId, keyId};\n    }\n    default:\n      throw new InvalidReferenceType(`Invalid reference type: ${type}`);\n  }\n}\n\nfunction matchUnitFloatType(unitFloatType: string): UnitFloatType {\n  if (!Object.values(UnitFloatType).includes(unitFloatType as UnitFloatType)) {\n    throw new InvalidUnitFloatType(`Invalid Unit Float type: ${unitFloatType}`);\n  }\n\n  return unitFloatType as UnitFloatType;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\n// Based on PDF grammar: https://web.archive.org/web/20220226063926/https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf\n// Section 7.2 - Lexical Conventions\n\nimport {\n  Cursor,\n  InvalidEngineDataBoolean,\n  InvalidEngineDataNumber,\n  InvalidEngineDataTextBOM,\n} from \"../utils\";\n\nexport enum TokenType {\n  String,\n  DictBeg,\n  DictEnd,\n  ArrBeg,\n  ArrEnd,\n  Name,\n  Number,\n  Boolean,\n}\n\nexport type Token =\n  | {type: TokenType.String; value: string}\n  | {type: TokenType.DictBeg}\n  | {type: TokenType.DictEnd}\n  | {type: TokenType.ArrBeg}\n  | {type: TokenType.ArrEnd}\n  | {type: TokenType.Name; value: string}\n  | {type: TokenType.Number; value: number}\n  | {type: TokenType.Boolean; value: boolean};\n\nconst WhitespaceCharacters = new Set([\n  0,\n  9,\n  12,\n  32, // ' '\n  10, // \\n\n  13, // \\r\n]);\n\nconst BooleanStartCharacters = new Set([\n  0x66, // f\n  0x74, // t\n]);\n\nconst Delimiters = {\n  \"(\": 0x28,\n  \")\": 0x29,\n  \"<\": 0x3c,\n  \">\": 0x3e,\n  \"[\": 0x5b,\n  \"]\": 0x5d,\n  \"/\": 0x2f,\n  \"\\\\\": 0x5c,\n  // NOTE: These have meaning within PDF. Are they used here?\n  // \"{\": 123,\n  // \"}\": 125,\n  // \"%\": 37,\n};\n\nconst DelimiterCharacters = new Set(Object.values(Delimiters));\n\nconst STRING_TOKEN_JT = [] as boolean[];\nfor (let i = 0; i < 256; i += 1) {\n  STRING_TOKEN_JT[i] =\n    WhitespaceCharacters.has(i) || DelimiterCharacters.has(i);\n}\n\nconst STRING_DECODER = new TextDecoder(\"utf-8\");\nfunction stringToken(cursor: Cursor): string {\n  const startsAt = cursor.position;\n  let endsAt = cursor.position;\n  for (const i of cursor.iter()) {\n    if (STRING_TOKEN_JT[i]) {\n      break;\n    }\n    endsAt += 1;\n  }\n  const text = STRING_DECODER.decode(cursor.take(endsAt - startsAt));\n  return text;\n}\n\nexport class Lexer {\n  cursor: Cursor;\n\n  constructor(cursor: Uint8Array) {\n    this.cursor = Cursor.from(cursor);\n  }\n\n  tokens(): Token[] {\n    const value = [] as Token[];\n    while (!this.done()) {\n      const val = this.cursor.one();\n\n      if (WhitespaceCharacters.has(val)) {\n        while (!this.done() && WhitespaceCharacters.has(this.cursor.peek()))\n          this.cursor.pass(1);\n        continue;\n      }\n      if (DelimiterCharacters.has(val)) {\n        if (val === Delimiters[\"(\"]) {\n          value.push({type: TokenType.String, value: this.text()});\n          continue;\n        }\n        if (val === Delimiters[\"[\"]) {\n          value.push({type: TokenType.ArrBeg});\n          continue;\n        }\n        if (val === Delimiters[\"]\"]) {\n          value.push({type: TokenType.ArrEnd});\n          continue;\n        }\n        if (val === Delimiters[\"<\"]) {\n          // NOTE: assert that it is < indeed?\n          this.cursor.pass(1);\n          value.push({type: TokenType.DictBeg});\n          continue;\n        }\n        if (val === Delimiters[\">\"]) {\n          // NOTE: assert that it is > indeed?\n          this.cursor.pass(1);\n          value.push({type: TokenType.DictEnd});\n          continue;\n        }\n        if (val === Delimiters[\"/\"]) {\n          value.push({type: TokenType.Name, value: this.string()});\n          continue;\n        }\n        console.assert(\n          false,\n          \"Unhandled delimiter: '%s'\",\n          String.fromCharCode(val)\n        );\n        continue;\n      }\n      // only two types left: number or boolean\n      // we need to return val first since it starts value\n      this.cursor.unpass(1);\n      if (BooleanStartCharacters.has(val)) {\n        value.push({type: TokenType.Boolean, value: this.boolean()});\n      } else {\n        value.push({type: TokenType.Number, value: this.number()});\n      }\n    }\n    return value;\n  }\n\n  private done(): boolean {\n    return this.cursor.position >= this.cursor.length;\n  }\n\n  private text(): string {\n    const firstByte = this.cursor.peek();\n    if (firstByte === Delimiters[\")\"]) {\n      this.cursor.pass(1);\n      return \"\";\n    }\n    const hasBom = firstByte === 0xff || firstByte === 0xfe;\n    let decoder = new TextDecoder(\"utf-16be\");\n    if (hasBom) {\n      decoder = this.textDecoderFromBOM();\n    }\n    const textParts = [] as string[];\n    const readAhead = this.cursor.clone();\n    while (readAhead.peek() !== Delimiters[\")\"]) {\n      readAhead.pass(1);\n      if (readAhead.peek() === Delimiters[\"\\\\\"]) {\n        const length = readAhead.position - this.cursor.position;\n        textParts.push(\n          decoder.decode(this.cursor.take(length), {stream: true})\n        );\n        readAhead.pass(2); // skip over \\\\\n        this.cursor.pass(1); // skip over escaped character to avoid decoding it in subsequent part\n        textParts.push(decoder.decode(this.cursor.take(1), {stream: true})); // push un-escaped character\n      }\n    }\n    const length = readAhead.position - this.cursor.position;\n    const raw = this.cursor.take(length);\n    textParts.push(decoder.decode(raw));\n    this.cursor.pass(1); // final )\n    return textParts.join(\"\");\n  }\n\n  private textDecoderFromBOM(): TextDecoder {\n    const firstBomPart = this.cursor.one();\n    const sndBomPart = this.cursor.one();\n    // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-16\n    // LE is FF FE\n    if (firstBomPart === 0xff && sndBomPart === 0xfe)\n      return new TextDecoder(\"utf-16le\");\n    // BE is FE FF\n    if (firstBomPart === 0xfe && sndBomPart === 0xff)\n      return new TextDecoder(\"utf-16be\");\n    throw new InvalidEngineDataTextBOM(\n      `Unknown BOM value: [${firstBomPart}, ${sndBomPart}]`\n    );\n  }\n\n  private string(): string {\n    return stringToken(this.cursor);\n  }\n\n  private number(): number {\n    const text = this.string();\n    const value = Number(text);\n    if (Number.isNaN(value)) {\n      throw new InvalidEngineDataNumber(`parsing '${text}' as Number failed`);\n    }\n    return value;\n  }\n\n  private boolean(): boolean {\n    const text = this.string();\n    if (text === \"true\") {\n      return true;\n    }\n    if (text === \"false\") {\n      return false;\n    }\n    throw new InvalidEngineDataBoolean(\n      `'${text}' is neither 'true' nor 'false'`\n    );\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  InvalidEngineDataDictKey,\n  InvalidTopLevelEngineDataValue,\n  UnexpectedEndOfEngineData,\n} from \"../utils\";\nimport {Token, TokenType} from \"./lexer\";\n\nexport type RawEngineData = {\n  [key: string]: RawEngineValue;\n};\nexport type RawEngineValue =\n  | string\n  | number\n  | boolean\n  | RawEngineValue[]\n  | RawEngineData;\n\nconst ARR_BOUNDARY = Symbol(TokenType[TokenType.ArrBeg]);\nconst DICT_BOUNDARY = Symbol(TokenType[TokenType.DictBeg]);\n\nexport class Parser {\n  private stack: (\n    | RawEngineValue\n    | typeof ARR_BOUNDARY\n    | typeof DICT_BOUNDARY\n  )[] = [];\n  constructor(private tokens: Iterable<Token>) {}\n\n  parse(): RawEngineData {\n    this.runParser();\n    const [value] = this.stack;\n    if (typeof value === \"object\" && !Array.isArray(value)) {\n      return value;\n    }\n    throw new InvalidTopLevelEngineDataValue(\n      `EngineData top-level value is not a dict; is ${typeof value}`\n    );\n  }\n\n  private runParser() {\n    for (const it of this.tokens) {\n      switch (it.type) {\n        case TokenType.Name:\n        case TokenType.Number:\n        case TokenType.Boolean:\n        case TokenType.String:\n          this.stack.push(it.value);\n          continue;\n        case TokenType.DictBeg:\n          this.stack.push(DICT_BOUNDARY);\n          continue;\n        case TokenType.ArrBeg:\n          this.stack.push(ARR_BOUNDARY);\n          continue;\n        case TokenType.DictEnd:\n          this.stack.push(this.dict());\n          continue;\n        case TokenType.ArrEnd:\n          this.stack.push(this.array().reverse());\n          continue;\n      }\n    }\n  }\n\n  private dict(): RawEngineData {\n    const val = {} as RawEngineData;\n    for (;;) {\n      const value = this.stack.pop();\n      // TODO: new error types?\n      if (value === undefined) {\n        throw new UnexpectedEndOfEngineData(\"Stack empty when parsing dict\");\n      }\n      if (value === DICT_BOUNDARY) {\n        return val;\n      }\n      if (value === ARR_BOUNDARY) {\n        throw new InvalidEngineDataDictKey(\"Got ArrBeg while parsing a dict\");\n      }\n      const it = this.stack.pop();\n      if (typeof it !== \"string\") {\n        throw new InvalidEngineDataDictKey(\n          `Dict key is not Name; is ${typeof it}`\n        );\n      }\n      val[it] = value;\n    }\n  }\n\n  private array(): RawEngineValue[] {\n    const val = [] as RawEngineValue[];\n    for (;;) {\n      const it = this.stack.pop();\n      // TODO: new error types?\n      if (it === undefined) {\n        throw new UnexpectedEndOfEngineData(\"Stack empty when parsing array\");\n      }\n      if (it === DICT_BOUNDARY) {\n        throw new InvalidEngineDataDictKey(\"Got DictBeg while parsing array\");\n      }\n      if (it === ARR_BOUNDARY) {\n        return val;\n      }\n      val.push(it);\n    }\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {EngineData} from \"../interfaces\";\n\nconst REQUIRED_KEYS = new Set([\n  \"DocumentResources\",\n  \"EngineDict\",\n  \"ResourceDict\",\n]);\n\nfunction hasOwnProperty<K extends string>(\n  obj: unknown,\n  prop: K\n): obj is Record<K, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function validateEngineData(\n  engineData: unknown\n): engineData is EngineData {\n  let ok = true;\n  if (typeof engineData !== \"object\") {\n    return false;\n  }\n  if (!engineData) {\n    return false;\n  }\n  for (const key of REQUIRED_KEYS) {\n    if (hasOwnProperty(engineData, key)) {\n      const value = engineData[key];\n      ok =\n        ok &&\n        typeof value === \"object\" &&\n        !Array.isArray(value) &&\n        Boolean(value);\n    } else {\n      return false;\n    }\n  }\n  return ok;\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {Lexer, Parser, validateEngineData} from \"../engineData\";\nimport {EngineData} from \"../interfaces\";\nimport {MissingEngineDataProperties} from \"../utils\";\n\nexport function parseEngineData(raw: Uint8Array): EngineData {\n  const value = new Parser(new Lexer(raw).tokens()).parse();\n  if (validateEngineData(value)) {\n    return value;\n  }\n  throw new MissingEngineDataProperties(\n    `Object with keys ${JSON.stringify(\n      Object.keys(value)\n    )} is not valid EngineData`\n  );\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {ImageData} from \"../interfaces\";\nimport {applyOpacity, generateRgba} from \"../methods\";\n\nexport abstract class Synthesizable {\n  public abstract get width(): number;\n  public abstract get height(): number;\n  public abstract get opacity(): number;\n  public abstract get composedOpacity(): number;\n\n  protected abstract get imageData(): ImageData;\n\n  async composite(effect = true, composed = true): Promise<Uint8ClampedArray> {\n    const {red, green, blue, alpha} = this.imageData;\n    const {width, height} = this;\n\n    const rgba = await generateRgba(width, height, red, green, blue, alpha);\n\n    if (effect === true) {\n      if (composed === true) {\n        const c = this.composedOpacity * 255;\n        return applyOpacity(rgba, c);\n      } else {\n        return applyOpacity(rgba, this.opacity);\n      }\n    }\n\n    return rgba;\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {EngineData, ImageData} from \"../interfaces\";\nimport {decodeGrayscale} from \"../methods\";\nimport {LayerFrame, MaskData, LayerProperties} from \"../sections\";\nimport {area} from \"../utils\";\nimport {NodeParent} from \"./Node\";\nimport {NodeBase} from \"./NodeBase\";\nimport {Synthesizable} from \"./Synthesizable\";\n\n/**\n * A layer in a PSD file.\n * @alpha\n */\nexport class Layer\n  extends Synthesizable\n  implements NodeBase<NodeParent, never>\n{\n  readonly type = \"Layer\";\n  readonly children?: undefined;\n\n  /** @internal */\n  constructor(\n    private layerFrame: LayerFrame,\n    public readonly parent: NodeParent\n  ) {\n    super();\n  }\n\n  get name(): string {\n    return this.layerFrame.layerProperties.name;\n  }\n  get width(): number {\n    return this.layerFrame.width;\n  }\n  get height(): number {\n    return this.layerFrame.height;\n  }\n  get top(): number {\n    return this.layerFrame.layerProperties.top;\n  }\n  get left(): number {\n    return this.layerFrame.layerProperties.left;\n  }\n  get opacity(): number {\n    return this.layerFrame.layerProperties.opacity;\n  }\n  get composedOpacity(): number {\n    return this.parent.composedOpacity * (this.opacity / 255);\n  }\n  get maskData(): MaskData {\n    return this.layerFrame.layerProperties.maskData;\n  }\n\n  async userMask(): Promise<Uint8Array | undefined> {\n    const userMask = this.layerFrame.userMask;\n    if (!userMask) {\n      return undefined;\n    }\n    return decodeGrayscale(area(this.maskData), userMask);\n  }\n\n  async realUserMask(): Promise<Uint8Array | undefined> {\n    const maskData = this.maskData.realData;\n    const userMask = this.layerFrame.realUserMask;\n    if (!maskData || !userMask) {\n      return undefined;\n    }\n    return decodeGrayscale(area(maskData), userMask);\n  }\n\n  get isHidden(): boolean {\n    return this.layerFrame.layerProperties.hidden;\n  }\n\n  get isTransparencyLocked(): boolean {\n    return this.layerFrame.layerProperties.transparencyLocked;\n  }\n\n  get additionalProperties(): LayerProperties[\"additionalLayerProperties\"] {\n    return this.layerFrame.layerProperties.additionalLayerProperties;\n  }\n\n  /**\n   * If this layer is a text layer, this property retrieves its text content.\n   * Otherwise, this property is `undefined`.\n   */\n  get text(): string | undefined {\n    return this.layerFrame.layerProperties.text;\n  }\n\n  /**\n   * If this layer is a text layer, this property retrieves its text properties.\n   * Otherwise, this property is `undefined`.\n   */\n  get textProperties(): EngineData | undefined {\n    return this.layerFrame.layerProperties.textProperties;\n  }\n\n  protected get imageData(): ImageData {\n    const {red, green, blue, alpha} = this.layerFrame;\n\n    return {red, green, blue, alpha};\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {PsdError} from \"../utils\";\nimport {Group} from \"./Group\";\nimport {Layer} from \"./Layer\";\nimport {Psd} from \"./Psd\";\n\nexport type Node = Psd | Group | Layer;\nexport type NodeParent = Psd | Group;\nexport type NodeChild = Group | Layer;\n\nexport function isNodeParent(node: Node): node is NodeParent {\n  return node.type === \"Psd\" || node.type === \"Group\";\n}\n\nexport function isNodeChild(node: Node): node is NodeChild {\n  return node.type === \"Group\" || node.type === \"Layer\";\n}\n\nexport function assertIsNodeParent(node: Node): asserts node is NodeParent {\n  if (!isNodeParent(node)) {\n    throw new PsdError(\n      `Node (name = '${node.name}', type: '${node.type}') cannot be a parent node`\n    );\n  }\n}\n\nexport function assertIsNodeChild(node: Node): asserts node is NodeChild {\n  if (!isNodeChild(node)) {\n    throw new PsdError(\n      `Node (name = '${node.name}', type: '${node.type}') cannot be a child node`\n    );\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  Descriptor,\n  DescriptorValueType,\n  getDescriptorValueAsType,\n  SliceOrigin,\n  SlicesResourceBlock,\n} from \"../interfaces\";\nimport {InvalidSlice as InvalidSlices} from \"../utils\";\n\n/**\n * Represents a single slice in a PSD file.\n * @alpha\n */\nexport class Slice {\n  constructor(\n    public origin: SliceOrigin,\n    public left: number,\n    public top: number,\n    public right: number,\n    public bottom: number\n  ) {}\n}\n\nexport function loadSlicesFromResourceBlock(block: SlicesResourceBlock) {\n  // We assume that most users use sufficiently modern versions of Photoshop\n  // (>= 7.0), which store the slices in descriptors.\n  // This saves us from having to write the same code twice.\n  if (block.resource.descriptor) {\n    const sliceList = block.resource.descriptor.descriptor.items.get(\"slices\");\n    if (!(sliceList && sliceList.type === DescriptorValueType.List)) {\n      throw new InvalidSlices(`Missing key \"slices\" in slice descriptor`);\n    }\n\n    return sliceList.values.reduce<Slice[]>((slices, listEntry) => {\n      if (listEntry.type !== DescriptorValueType.Descriptor) {\n        throw new InvalidSlices(\n          `Slice list contains a non-descriptor (type: ${listEntry.type})`\n        );\n      }\n\n      // The list entry is a descriptor that represents a single slice\n      slices.push(extractSliceFromDescriptor(listEntry.descriptor));\n      return slices;\n    }, []);\n  } else {\n    // No descriptor (i.e. Photoshop 6.0 format)\n    // While we can technically parse this, we choose not to.\n    // We can revisit this decision when we discover that some users want to use\n    // old versions of Photoshop.\n    throw new InvalidSlices(`No slice descriptor in slice resource block`);\n  }\n}\n\nfunction extractSliceFromDescriptor(descriptor: Descriptor) {\n  const origin = extractSliceOrigin(descriptor);\n\n  const boundsDescriptor = getDescriptorValueAsType(\n    descriptor,\n    \"bounds\",\n    DescriptorValueType.Descriptor\n  ).descriptor;\n  const top = getDescriptorValueAsType(\n    boundsDescriptor,\n    \"Top \",\n    DescriptorValueType.Integer\n  ).value;\n  const left = getDescriptorValueAsType(\n    boundsDescriptor,\n    \"Left\",\n    DescriptorValueType.Integer\n  ).value;\n  const bottom = getDescriptorValueAsType(\n    boundsDescriptor,\n    \"Btom\",\n    DescriptorValueType.Integer\n  ).value;\n  const right = getDescriptorValueAsType(\n    boundsDescriptor,\n    \"Rght\",\n    DescriptorValueType.Integer\n  ).value;\n\n  return new Slice(origin, left, top, right, bottom);\n}\n\nfunction extractSliceOrigin(sliceDescriptor: Descriptor) {\n  const originEnum = getDescriptorValueAsType(\n    sliceDescriptor,\n    \"origin\",\n    DescriptorValueType.Enumerated\n  );\n\n  if (originEnum.enumType !== \"ESliceOrigin\") {\n    throw new InvalidSlices(\n      `Unexpected enum type for slice origin: got \"${originEnum.enumType}\"`\n    );\n  }\n\n  switch (originEnum.enumValue) {\n    case \"layerGenerated\":\n      return SliceOrigin.LayerGenerated;\n    case \"userGenerated\":\n      return SliceOrigin.UserGenerated;\n    case \"autoGenerated\":\n      return SliceOrigin.AutoGenerated;\n    default:\n      throw new InvalidSlices(\n        `Unexpected enum value for slice origin: got \"${originEnum.enumValue}\"`\n      );\n  }\n}\n","// @webtoon/psd\n// Copyright 2021-present NAVER WEBTOON\n// MIT License\n\nimport {\n  ColorMode,\n  Depth,\n  Guide,\n  ImageData,\n  ParsingResult,\n  ResolutionInfo,\n  ResourceType,\n} from \"../interfaces\";\nimport {parse} from \"../methods\";\nimport {AdditionalLayerProperties} from \"../sections\";\nimport {Group} from \"./Group\";\nimport {Layer} from \"./Layer\";\nimport {assertIsNodeParent, Node, NodeChild} from \"./Node\";\nimport {NodeBase} from \"./NodeBase\";\nimport {loadSlicesFromResourceBlock, Slice} from \"./Slice\";\nimport {Synthesizable} from \"./Synthesizable\";\n\n/**\n * A parsed PSD file.\n * @alpha\n */\nexport class Psd extends Synthesizable implements NodeBase<never, NodeChild> {\n  public readonly name = \"ROOT\";\n  public readonly type = \"Psd\";\n  public readonly opacity = 255;\n  public readonly composedOpacity = 1;\n  public readonly parent?: undefined;\n  public readonly children: NodeChild[] = [];\n  public readonly layers: Layer[] = [];\n  public readonly guides: Guide[] = [];\n  public readonly slices: Slice[] = [];\n  public readonly icc_profile?: Uint8Array = undefined;\n  public readonly globalLightAngle?: number = undefined;\n  public readonly globalLightAltitude?: number = undefined;\n  public readonly resolutionInfo?: ResolutionInfo = undefined;\n  public readonly additionalLayerProperties: AdditionalLayerProperties = [];\n\n  static parse(buffer: ArrayBuffer): Psd {\n    const parsingResult = parse(buffer);\n    return new Psd(parsingResult);\n  }\n\n  /** @internal */\n  constructor(private parsingResult: ParsingResult) {\n    super();\n\n    this.buildTreeStructure();\n\n    this.additionalLayerProperties =\n      parsingResult.layerAndMaskInfo.globalAdditionalLayerInformation;\n\n    for (const resource of parsingResult.imageResources.resources) {\n      if (resource.resource !== null) {\n        switch (resource.id) {\n          case ResourceType.GridAndGuides:\n            this.guides = resource.resource.guides;\n            break;\n          case ResourceType.Slices:\n            this.slices = loadSlicesFromResourceBlock(resource);\n            break;\n          case ResourceType.ICCProfile:\n            // We don't want to do try parsing it ourselves since it'd cost us a lot\n            // see https://github.com/webtoon/psd/issues/46#issuecomment-1210726858\n            this.icc_profile = resource.resource;\n            break;\n          case ResourceType.GlobalLightAltitude:\n            this.globalLightAltitude = resource.resource;\n            break;\n          case ResourceType.GlobalLightAngle:\n            this.globalLightAngle = resource.resource;\n            break;\n          case ResourceType.ResolutionInfo:\n            this.resolutionInfo = resource.resource;\n            break;\n        }\n      }\n    }\n  }\n\n  get width(): number {\n    return this.parsingResult.fileHeader.width;\n  }\n  get height(): number {\n    return this.parsingResult.fileHeader.height;\n  }\n  get channelCount(): number {\n    return this.parsingResult.fileHeader.channelCount;\n  }\n  get depth(): Depth {\n    return this.parsingResult.fileHeader.depth;\n  }\n  get colorMode(): ColorMode {\n    return this.parsingResult.fileHeader.colorMode;\n  }\n\n  protected get imageData(): ImageData {\n    const {compression, red, green, blue, alpha} = this.parsingResult.imageData;\n    return {\n      red: {compression, data: red},\n      green: green ? {compression, data: green} : undefined,\n      blue: blue ? {compression, data: blue} : undefined,\n      alpha: alpha ? {compression, data: alpha} : undefined,\n    };\n  }\n\n  protected buildTreeStructure(): void {\n    const {groups, layers, orders} = this.parsingResult.layerAndMaskInfo;\n    const stack: Node[] = [this];\n    let groupIndex = 0,\n      layerIndex = 0;\n\n    // Build tree\n    orders.forEach((e) => {\n      const parent = stack[stack.length - 1];\n\n      switch (e) {\n        case \"G\": {\n          const layerFrame = groups[groupIndex];\n          assertIsNodeParent(parent);\n          const group = new Group(layerFrame, parent);\n\n          stack.push(group);\n          parent.children.push(group);\n          groupIndex += 1;\n\n          break;\n        }\n        case \"L\": {\n          const layerFrame = layers[layerIndex];\n          assertIsNodeParent(parent);\n          const layer = new Layer(layerFrame, parent);\n\n          this.layers.push(layer);\n          parent.children.push(layer);\n          layerIndex += 1;\n\n          break;\n        }\n        case \"D\": {\n          stack.pop();\n        }\n      }\n    });\n\n    // Free stack\n    stack.length = 0;\n\n    // Freeze children\n    this.children.forEach((node) => (node as NodeBase).freeze?.());\n    Object.freeze(this.children);\n  }\n}\n"],"names":["Group","layerFrame","parent","_a","_b","node","AliKey","SectionDividerSubtype","PathRecordType","equals","compare","target","length","i","PsdError","message","InvalidSignature","InvalidVersion","InvalidReservationCode","InvalidColorMode","InvalidDepth","InvalidChannelCount","InvalidPixelCount","InvalidBlendingModeSignature","InvalidGroupDividerType","UnknownBlendingMode","InvalidCompression","UnsupportedCompression","UnsupportedDepth","UnsupportedChannelKindOffset","ChannelNotFound","InvalidClipping","PanicFrameStackUnmatched","InvalidOpacityValue","InvalidResourceSignature","PanicOutOfBoundArray","InvalidGridAndGuidesVersion","InvalidGuideDirection","InvalidSlicesVersion","InvalidSliceOrigin","InvalidSlice","NumberTooLarge","InvalidAdditionalLayerInfoSignature","InvalidSectionDividerSetting","InvalidTypeToolObjectSetting","InvalidLinkedLayerType","InvalidDescriptorType","InvalidDescriptorVersion","DuplicateDescriptorKey","MissingDescriptorKey","UnexpectedDescriptorValueType","InvalidReferenceType","InvalidUnitFloatType","InvalidEngineDataBoolean","InvalidEngineDataNumber","InvalidTopLevelEngineDataValue","UnexpectedEndOfEngineData","InvalidEngineDataDictKey","InvalidEngineDataTextBOM","MissingEngineDataProperties","getUint64FromDataView","data","byteOffset","upper","lower","getInt64FromDataView","INCREASE","Cursor","dataView","position","bytes","pos","val","type","padding","lengthBytes","result","size","divisor","remainder","inRange","x","min","max","height","boundingBox","width","area","BlendMode","matchBlendMode","mode","keys","key","Clipping","matchClipping","ColorMode","Depth","DescriptorValueType","UnitFloatType","getDescriptorValueAsType","descriptor","valueType","value","PsdVersion","EXPECTED_SIGNATURE","EXPECTED_RESERVED","EXPECTED_DEPTH_KINDS","MIN_CHANNEL_COUNT","MAX_CHANNEL_COUNT","MIN_PIXEL","parseFileHeader","cursor","signature","version","fileVersionSpec","getFileVersionSpec","reserved","channelCount","depth","colorMode","readRawData","bytesCountPerChannel","red","green","blue","alpha","readRleCompressedData","redByteCount","greenByteCount","blueByteCount","alphaByteCount","byteCountReadType","channelDataStart","_cursor","parseImageData","compression","ChannelCompression","readGridAndGuides","gridSizeX","gridSizeY","guideCount","guides","direction","matchGuideDirection","readICCProfile","expectedEndPos","readResolutionInfo","horizontal","horizontalUnit","widthUnit","vertical","verticalUnit","heightUnit","readSlices","boundTop","boundLeft","boundBottom","boundRight","sliceGroupName","sliceCount","slices","id","groupId","origin","matchSliceOrigin","associatedLayerId","readVersionedDescriptor","EXPECTED_RESOURCE_BLOCK_SIGNATURE","parseImageResource","resources","block","readResourceBlock","name","readPascalString","dataLength","expectedDataEnd","paddedDataLength","dataBegin","resource","ResourceType","dataEnd","remainingBytes","alignment","createLayerProperties","layerRecord","top","left","bottom","right","opacity","clippingMask","hidden","transparencyLocked","blendMode","layerText","engineData","maskData","additionalLayerInfos","LayerFrame","channels","layerProperties","channelBytes","ChannelKind","GroupFrame","readArtboardDataAliBlock","readBlendOptionsCapacityAliBlock","readGradientFillSettingAliBlock","readHSL","hue","saturation","lightness","readHSLChange","beginRamp","beginSustain","endSustain","endRamp","readAdjustment","readHueSaturationAliBlock","colorize","colorization","master","readLayerIdAliBlock","readLinkedLayerAliBlock","layers","nextFileLength","endAt","layer","readLayer","advancedSoFar","undocumentedDataLength","layerType","uniqueId","readUniqueId","filename","filetype","creator","filelength","contents","uuid","uniqueIDLength","readObjectBasedEffectsAliBlock","descriptorVersion","readDescriptor","readPatternFillSettingAliBlock","readSectionDividerSettingAliBlock","dividerType","matchDividerType","dividerSignature","subType","readSmartObjectPlacedLayerDataAliBlock","identifier","readSolidColorSheetSettingAliBlock","readTypeToolObjectSettingAliBlock","transformXX","transformXY","transformYX","transformYY","transformTX","transformTY","textVersion","textData","warpVersion","warpData","readUnicodeLayerNameAliBlock","readFixedPoint32bit","beforeValue","afterPoint","afterValue","readPoint","vert","horiz","readSubpath","operation","subpathType","index","readClipboard","bounds","resolution","readFillRule","fill","readBezierKnot","preceding","anchor","leaving","readPathRecord","readPathRecords","count","readVectorMaskSettingAliBlock","flags","pathRecords","readVectorStrokeContentDataAliBlock","readVectorStrokeDataAliBlock","readAdditionalLayerInfo","getAliLengthFieldSizeType","prevPosition","aliBlock","readAliBlockBody","EXPECTED_BLENDING_MODE_SIGNATURE","readLayerRecordsAndChannels","layerCount","layerRecords","readLayerRecord","readLayerChannels","readLayerRectangle","channelInformation","channelKind","channelDataLength","clipping","readLayerFlags","layerExtraDataSize","layerExtraDataBegin","readMaskData","nameLength","ali","textValue","rawEngineData","parseEngineData","readGlobalAdditionalLayerInformation","realMask","calcLayerHeight","channelId","matchChannelCompression","rleCompressedSize","scanLines","readType","a","b","startsAt","readBounds","backgroundColor","readFlags","realData","readRealData","parameters","readParameters","MaskFlagsBitmask","MaskParameterBitmask","parseLayerAndMaskInformation","absLayerCount","layerRecordsAndChannels","globalAdditionalLayerInformation","groups","orders","stack","alreadyViewed","currentGroupId","GroupDivider","frame","_layerRecord","FILE_HEADER_SECTION_LENGTH","parseSectionInfo","start","lengthFieldSize","getFileStructure","buffer","fhStart","fhSize","fileHeaderView","fileHeader","cmd","ir","lmi","PsdSpec","PsbSpec","fileVersion","getChannelKindOffset","divider","GuideDirection","SliceOrigin","ResolutionUnit","DimensionUnit","ReferenceType","applyOpacity","pixels","offset","j","e","Z","q","d","K","W","p","oA","u","V","A","B","I","C","Q","g","Y","r","R","v","z","O","U","s","n","X","D","o","S","J","H","E","F","k","N","M","f","t","l","IA","w","c","y","h","DA","wA","GA","NA","gA","QA","CA","_","P","L","$","AA","EA","G","iA","generateRgba","pixelCount","decodeRgb","decodeGrayscale","validateSupportedCompression","wasmDecoder.init","wasmDecoder.decode_rgba","wasmDecoder.decode_rgb","color","wasmDecoder.decode_grayscale_a","wasmDecoder.decode_grayscale","parse","fileStructure","imageResources","layerAndMaskInfo","imageData","classId","itemCount","items","readDescriptorValue","enumType","enumValue","valueCount","values","references","readReference","unitType","matchUnitFloatType","itemsCount","valuesCount","typeId","keyId","unitFloatType","TokenType","WhitespaceCharacters","BooleanStartCharacters","Delimiters","DelimiterCharacters","STRING_TOKEN_JT","STRING_DECODER","stringToken","endsAt","Lexer","firstByte","hasBom","decoder","textParts","readAhead","raw","firstBomPart","sndBomPart","text","ARR_BOUNDARY","DICT_BOUNDARY","Parser","tokens","it","REQUIRED_KEYS","hasOwnProperty","obj","prop","validateEngineData","ok","Synthesizable","effect","composed","rgba","Layer","userMask","isNodeParent","assertIsNodeParent","Slice","loadSlicesFromResourceBlock","sliceList","InvalidSlices","listEntry","extractSliceFromDescriptor","extractSliceOrigin","boundsDescriptor","sliceDescriptor","originEnum","Psd","parsingResult","groupIndex","layerIndex","group"],"mappings":"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"}